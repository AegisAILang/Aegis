{"filePath": "requirements.txt", "language": "unknown", "content": "llvmlite\npandas\nace_tools\ndebugpy\nos\nre\nsys\ntime\nctypes", "size": 55, "lastModified": 1741345565.6459372, "moduleContext": "", "structure": {}, "stats": {"line_count": 9, "function_count": 0, "class_count": 0, "complexity_estimate": 1}, "contentHash": "a9ad0d6e76120b2f2f7744fb1c52be7d"}
{"filePath": "install.sh", "language": "unknown", "content": "#!/bin/bash\necho \"Installing Aegis dependencies...\"\npip install llvmlite pandas ace_tools  # or wherever your dependencies live\n# Possibly: apt-get install clang, etc.\n\necho \"Aegis installation complete!\"\n", "size": 205, "lastModified": 1741345565.6452072, "moduleContext": "", "structure": {}, "stats": {"line_count": 7, "function_count": 0, "class_count": 0, "complexity_estimate": 1}, "contentHash": "61b65c99cf8c4b602d9a708296805415"}
{"filePath": "pyproject.toml", "language": "unknown", "content": "[tool.black]\nline-length = 88\ntarget-version = ['py312']\n\n[tool.ruff]\nline-length = 88\nselect = [\"E\", \"F\", \"W\", \"I001\"]\n\n[tool.mypy]\npython_version = \"3.12\"\nignore_missing_imports = true\ncheck_untyped_defs = true\n", "size": 213, "lastModified": 1741345565.645709, "moduleContext": "", "structure": {}, "stats": {"line_count": 13, "function_count": 0, "class_count": 0, "complexity_estimate": 1}, "contentHash": "49ee25753d7d4dc0a24e7e62c2a135ad"}
{"filePath": "README.md", "language": "Markdown", "content": "# Aegis - AI Control & Guidance\n\nAegis is an AI-optimized, high-performance, and type-safe programming language designed for deterministic, error-free code generation. Built on LLVM and WebAssembly, Aegis empowers developers to create secure and scalable applications with a focus on clarity and efficiency.\n\n## \ud83c\udf93 Why isn't this just another language?\n\n- Deterministic Sytax: Indentation-based with no hidden conversions.\n- Minimal Ambiguity:\n- Easy to Parse: Tokenized\n- Strong Typing: No null by default\n- Strict: Forces code correctness to help AI produce fewer errors.\n- Compiled, memory-safe, and type-safe by default.\n- Scalable & Modular: Support modules, package manager, and a standard library.\n- Compilation Targets: LLVM IR, WebAssembly, and native binaries.\n- **Made for AI:** Straightforward scoping, no tricky corner cases, and minimal variance.\n\n## \ud83d\udd25 Features\n\n- **AI-Optimized Code Generation:**  \n  Leverage AI-driven tools to automatically generate, validate, and optimize code.\n\n- **Strong Type Safety:**  \n  Aegis enforces strict typing with no null values, ensuring predictable behavior.\n\n- **High Performance:**  \n  Utilizes LLVM for native compilation and supports WebAssembly for portable, browser-based execution.\n\n- **Built-in Standard Library:**  \n  Includes robust functionality for arithmetic, string manipulation, file I/O, networking, and date/time operations.\n\n- **Modular Design & Package Management:**  \n  Easily structure your projects with modules and manage dependencies with Aegis\u2019 integrated package manager.\n\n## Installation\n\nClone the repository and run the installation script to set up Aegis on your system:\n\n```bash\ngit clone https://github.com/your-username/aegis.git\ncd aegis\n./install.sh\n```\n\nNote: Ensure you have LLVM, Clang, and Python 3 installed on your system.\n\n## Usage\n\n### Compiling Aegis Code\n\nTo compile an Aegis source file (e.g., example.ae), run:\n\n```bash\npython compiler/aegis_compiler.py examples/example.ae\n```\n\nThis will:\n    - Tokenize and parse your source code.\n    - Perform semantic analysis and type checking.\n    - Generate LLVM IR.\n    - Optionally run JIT compilation to execute your code.\n\n### AI-Driven Code Generation\n\nAegis includes an AI code generator for scaffolding SaaS modules and enterprise projects. To generate sample code:\n\n```bash\npython compiler/aegis_ai_generator.py\n```\n\nThis script will output AI-generated Aegis code that you can further modify.\n\n### Example\n\nBelow is a simple Aegis example:\n\n```bash\nmodule UserSystem:\n\n    struct User:\n        name: string\n        age: int\n\n    fn get_user(name: string) -> User:\n        return User(name, 25)\n```\n\nSave this as examples/example.ae and compile it using the instructions above.\n\n## \ud83d\udcdd Contributing\n\nWe welcome contributions to Aegis! Please check out our CONTRIBUTING.md for guidelines on how to get started. In general, pull requests are welcome! However, please open an issue for major changes to start a discussion.\n\n## Roadmap\n\n- [] Establish documentation \ud83d\udcda.\n- [] Enhanced AI Assistance: Further integration of AI for code refactoring and error correction.\n- [] Expanded Standard Library: Additional modules for advanced networking, cryptography, and cloud-native development.\n- [] Tooling & IDE Support: Developing plugins and an online playground for real-time code generation and testing.\n- [] Performance Optimization: Continuous improvements to the LLVM backend and WebAssembly support.\n\n## \ud83d\udcc3 License\n\nAegis is open source under the [MIT](https://github.com/AurixLang/Aurix/blob/main/LICENSE) License.\n\n---\n## \ud83d\udde8\ufe0f Contact Us\n\n\u2b50 Star us on GitHub \u2014 it motivates us a lot!\n\n[![Share](https://img.shields.io/badge/share-000000?logo=x&logoColor=white)](https://x.com/intent/tweet?text=Check%20out%20this%20project%20on%20GitHub:%20https://github.com/Abblix/Oidc.Server%20%23OpenIDConnect%20%23Security%20%23Authentication)\n[![Share](https://img.shields.io/badge/share-1877F2?logo=facebook&logoColor=white)](https://www.facebook.com/sharer/sharer.php?u=https://github.com/Abblix/Oidc.Server)\n[![Share](https://img.shields.io/badge/share-0A66C2?logo=linkedin&logoColor=white)](https://www.linkedin.com/sharing/share-offsite/?url=https://github.com/Abblix/Oidc.Server)\n[![Share](https://img.shields.io/badge/share-FF4500?logo=reddit&logoColor=white)](https://www.reddit.com/submit?title=Check%20out%20this%20project%20on%20GitHub:%20https://github.com/Abblix/Oidc.Server)\n[![Share](https://img.shields.io/badge/share-0088CC?logo=telegram&logoColor=white)](https://t.me/share/url?url=https://github.com/Abblix/Oidc.Server&text=Check%20out%20this%20project%20on%20GitHub)\n\nJoin our community on Discord and follow us on Twitter for the latest updates and discussions.\n\nHappy coding with Aegis!", "size": 4738, "lastModified": 1741345565.6379657, "moduleContext": "", "structure": {}, "stats": {"line_count": 118, "function_count": 0, "class_count": 0, "complexity_estimate": 15}, "contentHash": "6bafda6a637ac79df53b31ef4de1b931"}
{"filePath": "ROADMAP.md", "language": "Markdown", "content": "# Aegis Roadmap\n\n## Upcoming Features\n\n- **AI-Powered IDE & Playground:**  \n  Develop an online environment for writing, compiling, and testing Aegis code with AI assistance.\n\n- **Expanded Standard Library:**  \n  Add modules for file I/O, networking, cryptography, and more advanced date/time functions.\n\n- **Performance Improvements:**  \n  Optimize the LLVM backend and expand support for native and WebAssembly targets.\n\n- **Tooling & Integration:**  \n  Create plugins for popular IDEs and improve the package manager for easier dependency management.\n\n## Long-Term Goals\n\n- **Cloud-Native Deployment Tools:**  \n  Enable seamless deployment of Aegis applications to cloud platforms like AWS, Azure, and Google Cloud.\n\n- **Community Growth:**  \n  Build a strong developer community with regular meetups, documentation, and support channels.\n", "size": 842, "lastModified": 1741345565.6381683, "moduleContext": "", "structure": {}, "stats": {"line_count": 24, "function_count": 0, "class_count": 0, "complexity_estimate": 6}, "contentHash": "dcaec552cc2e0b9575956fd5e16d8ea8"}
{"filePath": "tests/test_indentation.py", "language": "Python", "content": "\"\"\"\nTest suite for the AegisIndentationLexer.\n\nTests the indentation handling capabilities of the lexer, ensuring proper\nINDENT and DEDENT tokens are created and error detection works as expected.\n\"\"\"\n\nimport unittest\nfrom src.lexer.indentation_lexer import AegisIndentationLexer\nfrom antlr4 import InputStream, CommonTokenStream\nfrom AegisLangLexer import AegisLangLexer  # Auto-generated from ANTLR4\n\nclass MockLexer:\n    \"\"\"Mock lexer for testing the indentation lexer\"\"\"\n    def __init__(self):\n        self.tokens = []\n\nclass TestIndentationLexer(unittest.TestCase):\n    def setUp(self):\n        self.lexer = AegisIndentationLexer(MockLexer())\n\n    def test_basic_indentation(self):\n        \"\"\"Test basic indentation patterns\"\"\"\n        source = \"\"\"\nmodule Test:\n    fn function():\n        statement1\n        statement2\n    fn function2():\n        statement3\n\"\"\"\n        processed = self.lexer.process_indentation(source)\n        self.assertIn(\"INDENT\", processed)\n        self.assertIn(\"DEDENT\", processed)\n\n    def test_multi_level_indentation(self):\n        \"\"\"Test multiple levels of indentation\"\"\"\n        source = \"\"\"\nmodule Test:\n    fn function():\n        if condition:\n            statement1\n            statement2\n        statement3\n\"\"\"\n        processed = self.lexer.process_indentation(source)\n        lines = processed.split('\\n')\n        indent_count = sum(1 for line in lines if \"INDENT\" in line)\n        dedent_count = sum(1 for line in lines if \"DEDENT\" in line)\n        \n        # Should have 2 indents (for fn and if) and 2 dedents\n        self.assertEqual(indent_count, 2)\n        self.assertEqual(dedent_count, 2)\n\n    def test_mixed_indentation_error(self):\n        \"\"\"Test error detection with mixed indentation\"\"\"\n        source = \"\"\"\nmodule Test:\n    fn function():\n        statement1\n       wrong_indent\n\"\"\"\n        self.lexer.process_indentation(source)\n        # Should detect the indentation error\n        self.assertTrue(len(self.lexer.indent_errors) > 0)\n        error = self.lexer.indent_errors[0]\n        self.assertIn(\"IndentationError\", error[\"type\"])\n        self.assertIn(\"wrong_indent\", source)\n\n    def test_over_indentation_error(self):\n        \"\"\"Test error detection with over-indentation\"\"\"\n        source = \"\"\"\nmodule Test:\n    fn function():\n        statement1\n            over_indented\n\"\"\"\n        processed = self.lexer.process_indentation(source)\n        # Should still process it with INDENT but record an error\n        self.assertIn(\"INDENT\", processed)\n        self.assertTrue(len(self.lexer.indent_errors) > 0)\n\n    def test_empty_lines_and_comments(self):\n        \"\"\"Test handling of empty lines and comments\"\"\"\n        source = \"\"\"\nmodule Test:\n    # This is a comment\n    \n    fn function():\n        statement1\n        # Another comment\n        \n        statement2\n\"\"\"\n        processed = self.lexer.process_indentation(source)\n        # Comments and empty lines should be preserved\n        self.assertIn(\"# This is a comment\", processed)\n        self.assertIn(\"# Another comment\", processed)\n        \n        # Proper indentation should still work\n        self.assertIn(\"INDENT\", processed)\n\n    def test_dedent_handling(self):\n        \"\"\"Test multiple dedent levels are handled correctly\"\"\"\n        source = \"\"\"\nmodule Test:\n    fn outer():\n        if condition:\n            statement1\n        statement2\n\"\"\"\n        processed = self.lexer.process_indentation(source)\n        # Check that we dedent properly from the if block\n        dedent_line = None\n        for line in processed.split('\\n'):\n            if \"statement2\" in line and \"DEDENT\" in line:\n                dedent_line = line\n                break\n        \n        self.assertIsNotNone(dedent_line)\n        self.assertIn(\"DEDENT\", dedent_line)\n\n    def test_complex_nesting(self):\n        \"\"\"Test complex nesting patterns\"\"\"\n        source = \"\"\"\nmodule Test:\n    struct User:\n        name: string\n        age: int\n        \n    fn get_user(id: int) -> Option<User>:\n        if id > 0:\n            if db_connected():\n                return Some(User(\"Test\", 25))\n            else:\n                return None\n        return None\n\"\"\"\n        processed = self.lexer.process_indentation(source)\n        \n        # Count indents and dedents\n        indent_count = sum(1 for line in processed.split('\\n') if \"INDENT\" in line)\n        dedent_count = sum(1 for line in processed.split('\\n') if \"DEDENT\" in line)\n        \n        # Should have appropriate number of indents and dedents\n        self.assertEqual(indent_count, 3)  # module->struct, module->fn, fn->if, if->if\n        self.assertEqual(dedent_count, 3)  # or more with final dedents\n\n    def test_option_type_dsl_pattern(self):\n        \"\"\"Test indentation with Option<T> and DSL-like patterns\"\"\"\n        source = \"\"\"\nmodule OptTest:\n    fn process_optional(opt: Option<int>) -> int:\n        match opt:\n            Some(value) => \n                if value > 10:\n                    return value * 2\n                else:\n                    return value\n            None => \n                return 0\n\"\"\"\n        processed = self.lexer.process_indentation(source)\n        \n        # Should handle the match statement and nested if-else properly\n        self.assertIn(\"INDENT\", processed)\n        self.assertIn(\"DEDENT\", processed)\n        \n        # No indentation errors\n        self.assertEqual(len(self.lexer.indent_errors), 0)\n\nif __name__ == \"__main__\":\n    unittest.main()", "size": 5454, "lastModified": 1741357516.9706457, "moduleContext": "tests", "structure": {"classes": ["TestIndentationLexer", "MockLexer"], "functions": ["test_basic_indentation", "test_option_type_dsl_pattern", "test_over_indentation_error", "__init__", "test_dedent_handling", "test_complex_nesting", "setUp", "test_multi_level_indentation", "test_empty_lines_and_comments", "test_mixed_indentation_error"], "imports": ["ANTLR4", "InputStream", "AegisLangLexer", "unittest", "AegisIndentationLexer", "src", "the", "antlr4"]}, "stats": {"line_count": 173, "function_count": 10, "class_count": 2, "complexity_estimate": 37}, "contentHash": "45ae0b608ffec81fddabe37286b01493"}
{"filePath": "tests/test_ast_visitor.py", "language": "Python", "content": "\"\"\"\nTest suite for the AegisASTVisitor.\n\nTests that the visitor correctly visits and processes all grammar rules\nin the Aegis language, ensuring the AST structure is properly created.\n\"\"\"\n\nimport unittest\nfrom src.parser.aeigix_ast_visitor import AegisASTVisitor, SourcePosition\nfrom dataclasses import asdict\nfrom typing import Dict, Any\n\nclass TestASTVisitor(unittest.TestCase):\n    def setUp(self):\n        self.visitor = AegisASTVisitor(source_file=\"test.ae\")\n        \n    def test_visit_module(self):\n        \"\"\"Test module node visitation\"\"\"\n        # Create a mock module node\n        module_node = type('obj', (object,), {\n            'name': 'TestModule',\n            'body': [],\n            'line': 1,\n            'column': 1\n        })\n        \n        result = self.visitor.visit_module(module_node)\n        \n        self.assertEqual(result[\"node_type\"], \"module\")\n        self.assertEqual(result[\"name\"], \"TestModule\")\n        self.assertEqual(len(result[\"children\"]), 0)\n        \n    def test_visit_struct(self):\n        \"\"\"Test struct node visitation\"\"\"\n        # Create a mock struct node with fields\n        field1 = type('obj', (object,), {\n            'type': 'field',\n            'name': 'id',\n            'field_type': type('obj', (object,), {'name': 'int'}),\n            'line': 2,\n            'column': 5\n        })\n        field2 = type('obj', (object,), {\n            'type': 'field',\n            'name': 'name',\n            'field_type': type('obj', (object,), {'name': 'string'}),\n            'line': 3,\n            'column': 5\n        })\n        \n        struct_node = type('obj', (object,), {\n            'name': 'User',\n            'body': [field1, field2],\n            'line': 1,\n            'column': 1,\n            'traits': []\n        })\n        \n        result = self.visitor.visit_struct(struct_node)\n        \n        self.assertEqual(result[\"node_type\"], \"struct\")\n        self.assertEqual(result[\"name\"], \"User\")\n        self.assertEqual(len(result[\"fields\"]), 2)\n        self.assertEqual(result[\"fields\"][0][\"name\"], \"id\")\n        \n    def test_visit_function(self):\n        \"\"\"Test function node visitation\"\"\"\n        # Create a mock function node\n        ret_type = type('obj', (object,), {'name': 'int'})\n        param = type('obj', (object,), {\n            'name': 'x',\n            'param_type': type('obj', (object,), {'name': 'int'}),\n            'line': 2,\n            'column': 10\n        })\n        \n        stmt = type('obj', (object,), {\n            'type': 'return_statement',\n            'value': type('obj', (object,), {\n                'type': 'literal',\n                'value': 42,\n                'literal_type': 'int',\n                'line': 3,\n                'column': 12\n            }),\n            'line': 3,\n            'column': 5\n        })\n        \n        function_node = type('obj', (object,), {\n            'name': 'add',\n            'parameters': [param],\n            'return_type': ret_type,\n            'body': [stmt],\n            'line': 1,\n            'column': 1,\n            'type': 'function'\n        })\n        \n        result = self.visitor.visit_function(function_node)\n        \n        self.assertEqual(result[\"node_type\"], \"function\")\n        self.assertEqual(result[\"name\"], \"add\")\n        self.assertEqual(len(result[\"parameters\"]), 1)\n        self.assertEqual(result[\"parameters\"][0][\"name\"], \"x\")\n        \n    def test_visit_option_type(self):\n        \"\"\"Test option type visitation\"\"\"\n        # Create a mock Option<T> type node\n        inner_type = type('obj', (object,), {'name': 'User'})\n        option_type = type('obj', (object,), {\n            'name': 'Option',\n            'type_params': [inner_type],\n            'line': 1,\n            'column': 10\n        })\n        \n        # Mock a function return type using Option<User>\n        function_node = type('obj', (object,), {\n            'name': 'get_user',\n            'parameters': [],\n            'return_type': option_type,\n            'body': [],\n            'line': 1,\n            'column': 1,\n            'type': 'function'\n        })\n        \n        result = self.visitor.visit_function(function_node)\n        \n        # Verify that the return type is properly captured\n        self.assertEqual(result[\"node_type\"], \"function\")\n        self.assertEqual(result[\"name\"], \"get_user\")\n        # The return_type structure depends on visitor implementation\n        self.assertTrue(\"return_type\" in result)\n        \n    def test_visit_if_statement(self):\n        \"\"\"Test if statement visitation\"\"\"\n        # Create a mock if statement node\n        condition = type('obj', (object,), {\n            'type': 'binary_operation',\n            'operator': '>',\n            'left': type('obj', (object,), {\n                'type': 'identifier',\n                'name': 'x',\n                'line': 2,\n                'column': 5\n            }),\n            'right': type('obj', (object,), {\n                'type': 'literal',\n                'value': 0,\n                'literal_type': 'int',\n                'line': 2,\n                'column': 9\n            }),\n            'line': 2,\n            'column': 7\n        })\n        \n        then_stmt = type('obj', (object,), {\n            'type': 'return_statement',\n            'value': type('obj', (object,), {\n                'type': 'identifier',\n                'name': 'x',\n                'line': 3,\n                'column': 12\n            }),\n            'line': 3,\n            'column': 5\n        })\n        \n        else_stmt = type('obj', (object,), {\n            'type': 'return_statement',\n            'value': type('obj', (object,), {\n                'type': 'literal',\n                'value': 0,\n                'literal_type': 'int',\n                'line': 5,\n                'column': 12\n            }),\n            'line': 5,\n            'column': 5\n        })\n        \n        if_node = type('obj', (object,), {\n            'type': 'if_statement',\n            'condition': condition,\n            'then_branch': [then_stmt],\n            'else_branch': [else_stmt],\n            'line': 1,\n            'column': 1\n        })\n        \n        # Check if visitor has visit_if_statement method\n        if hasattr(self.visitor, 'visit_if_statement'):\n            result = self.visitor.visit_if_statement(if_node)\n            \n            self.assertEqual(result[\"node_type\"], \"if_statement\")\n            self.assertTrue(\"condition\" in result)\n            self.assertTrue(\"then_branch\" in result)\n            self.assertTrue(\"else_branch\" in result)\n    \n    def test_visit_match_statement(self):\n        \"\"\"Test match statement visitation\"\"\"\n        # Create a mock match statement with Option<T> patterns\n        \n        subject = type('obj', (object,), {\n            'type': 'identifier',\n            'name': 'result',\n            'line': 1,\n            'column': 7\n        })\n        \n        some_pattern = type('obj', (object,), {\n            'type': 'constructor_pattern',\n            'name': 'Some',\n            'bindings': [type('obj', (object,), {\n                'type': 'binding_pattern',\n                'name': 'value',\n                'line': 2,\n                'column': 10\n            })],\n            'line': 2,\n            'column': 5\n        })\n        \n        some_body = type('obj', (object,), {\n            'type': 'expression_statement',\n            'expression': type('obj', (object,), {\n                'type': 'identifier',\n                'name': 'value',\n                'line': 2,\n                'column': 20\n            }),\n            'line': 2,\n            'column': 15\n        })\n        \n        none_pattern = type('obj', (object,), {\n            'type': 'constructor_pattern',\n            'name': 'None',\n            'bindings': [],\n            'line': 3,\n            'column': 5\n        })\n        \n        none_body = type('obj', (object,), {\n            'type': 'literal',\n            'value': 0,\n            'literal_type': 'int',\n            'line': 3,\n            'column': 15\n        })\n        \n        branches = [\n            type('obj', (object,), {\n                'pattern': some_pattern,\n                'body': some_body,\n                'guard': None,\n                'line': 2,\n                'column': 5\n            }),\n            type('obj', (object,), {\n                'pattern': none_pattern,\n                'body': none_body,\n                'guard': None,\n                'line': 3,\n                'column': 5\n            })\n        ]\n        \n        match_node = type('obj', (object,), {\n            'type': 'match_statement',\n            'subject': subject,\n            'branches': branches,\n            'line': 1,\n            'column': 1\n        })\n        \n        # Check if visitor has visit_match_statement method\n        if hasattr(self.visitor, 'visit_match_statement'):\n            result = self.visitor.visit_match_statement(match_node)\n            \n            self.assertEqual(result[\"node_type\"], \"match_statement\")\n            self.assertTrue(\"subject\" in result)\n            self.assertTrue(\"branches\" in result)\n            self.assertEqual(len(result[\"branches\"]), 2)\n    \n    def test_visit_async_function(self):\n        \"\"\"Test async function visitation\"\"\"\n        # Create a mock async function node\n        ret_type = type('obj', (object,), {'name': 'string'})\n        \n        stmt = type('obj', (object,), {\n            'type': 'return_statement',\n            'value': type('obj', (object,), {\n                'type': 'literal',\n                'value': \"result\",\n                'literal_type': 'string',\n                'line': 2,\n                'column': 12\n            }),\n            'line': 2,\n            'column': 5\n        })\n        \n        async_function_node = type('obj', (object,), {\n            'name': 'fetch_data',\n            'parameters': [],\n            'return_type': ret_type,\n            'body': [stmt],\n            'line': 1,\n            'column': 1,\n            'type': 'function',\n            'is_async': True  # Indicate this is an async function\n        })\n        \n        # Check if visitor properly handles async functions\n        result = self.visitor.visit_function(async_function_node)\n        \n        self.assertEqual(result[\"node_type\"], \"function\")\n        self.assertEqual(result[\"name\"], \"fetch_data\")\n        # The is_async attribute depends on visitor implementation\n        if \"is_async\" in result:\n            self.assertTrue(result[\"is_async\"])\n    \n    def test_source_position_tracking(self):\n        \"\"\"Test that source positions are tracked correctly\"\"\"\n        # Create a node with line and column information\n        node = type('obj', (object,), {\n            'name': 'test',\n            'body': [],\n            'line': 42,\n            'column': 10\n        })\n        \n        # Test with visitor's _make_node_info helper method\n        pos = SourcePosition(42, 10, \"test.ae\")\n        node_info = self.visitor._make_node_info(\"test\", \"test\", [], pos)\n        \n        self.assertEqual(node_info[\"position\"].line, 42)\n        self.assertEqual(node_info[\"position\"].column, 10)\n        self.assertEqual(node_info[\"position\"].file_path, \"test.ae\")\n\nif __name__ == \"__main__\":\n    unittest.main()", "size": 11241, "lastModified": 1741357572.9502175, "moduleContext": "tests", "structure": {"classes": ["TestASTVisitor"], "functions": ["test_source_position_tracking", "test_visit_struct", "test_visit_async_function", "test_visit_match_statement", "setUp", "test_visit_if_statement", "test_visit_option_type", "test_visit_module", "test_visit_function"], "imports": ["dataclasses", "AegisASTVisitor", "unittest", "src", "Dict", "asdict", "typing"]}, "stats": {"line_count": 346, "function_count": 9, "class_count": 1, "complexity_estimate": 16}, "contentHash": "20e8549ed63455ed7dea7e5ffda0cdab"}
{"filePath": "tests/test_compiler.py", "language": "Python", "content": "# tests/test_compiler.py\n\n\"\"\"\nTest suite for AegisLang Compiler.\nUses unittest to ensure the compiler (lexer, parser, type checker, IR generator) works.\n\"\"\"\n\nimport unittest\nfrom src.lexer.lexer import lex\nfrom src.parser.parser import AegisParser\nfrom src.compiler.type_checker import TypeChecker\nfrom src.compiler.code_generator import CodeGenerator\n\n\nclass TestAegisCompiler(unittest.TestCase):\n    def setUp(self):\n        # Example AegisLang source to test\n        self.source_code = \"\"\"\nmodule TestModule:\n    struct Test:\n        id: int\n        name: string\n\n    fn get_test(id: int) -> Test:\n        return Test(id, \"Sample\")\n\"\"\"\n        self.tokens = lex(self.source_code)\n        self.parser = AegisParser(self.tokens)\n        self.ast = self.parser.parse()\n\n    def test_type_checker(self):\n        type_checker = TypeChecker(self.ast)\n        result = type_checker.check()\n        self.assertEqual(result, \"Semantic Analysis Passed\")\n\n    def test_code_generation(self):\n        code_gen = CodeGenerator(self.ast)\n        llvm_ir = code_gen.generate()\n        self.assertIn(\"define\", llvm_ir)\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "size": 1155, "lastModified": 1741346461.4856079, "moduleContext": "tests", "structure": {"classes": ["TestAegisCompiler"], "functions": ["test_code_generation", "test_type_checker", "setUp"], "imports": ["TypeChecker", "CodeGenerator", "unittest", "src", "lex", "AegisParser"]}, "stats": {"line_count": 44, "function_count": 3, "class_count": 1, "complexity_estimate": 4}, "contentHash": "7a12843305bb4dae1dc9abb45a5a27e6"}
{"filePath": "tests/test_semantic.py", "language": "Python", "content": "\"\"\"\nTest suite for the semantic analysis components of Aegis.\n\nTests type checking, symbol resolution, and semantic validation to ensure\nthe language adheres to its type safety and deterministic design principles.\n\"\"\"\n\nimport unittest\nfrom src.semantic.type_checker import TypeChecker\nfrom src.semantic.symbol_table import SymbolTable, Symbol, SymbolType, Scope\nfrom src.parser.aeigix_ast_visitor import SourcePosition\n\nclass TestSemanticAnalysis(unittest.TestCase):\n    def setUp(self):\n        self.type_checker = TypeChecker()\n        \n    def test_basic_type_checking(self):\n        \"\"\"Test basic type checking for compatible types\"\"\"\n        # Create a simple AST with an assignment of compatible types\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"variable_declaration\",\n                \"name\": \"x\",\n                \"var_type\": {\"name\": \"int\"},\n                \"init_value\": {\n                    \"node_type\": \"literal\",\n                    \"literal_type\": \"int\",\n                    \"value\": 42,\n                    \"position\": SourcePosition(1, 1, \"test.ae\")\n                },\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        errors = self.type_checker.check(ast)\n        self.assertEqual(len(errors), 0, \"No type errors should be found\")\n        \n    def test_incompatible_types(self):\n        \"\"\"Test detection of incompatible types\"\"\"\n        # Create an AST with an incompatible type assignment\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"variable_declaration\",\n                \"name\": \"x\",\n                \"var_type\": {\"name\": \"int\"},\n                \"init_value\": {\n                    \"node_type\": \"literal\",\n                    \"literal_type\": \"string\",\n                    \"value\": \"hello\",\n                    \"position\": SourcePosition(1, 1, \"test.ae\")\n                },\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        errors = self.type_checker.check(ast)\n        self.assertGreater(len(errors), 0, \"Type error should be detected\")\n        self.assertIn(\"type\", str(errors[0]).lower())\n\n    def test_undefined_symbol(self):\n        \"\"\"Test detection of undefined symbols\"\"\"\n        # Create an AST with an undefined variable reference\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"test_func\",\n                \"parameters\": [],\n                \"return_type\": {\"name\": \"void\"},\n                \"body\": [{\n                    \"node_type\": \"expression_statement\",\n                    \"expression\": {\n                        \"node_type\": \"identifier\",\n                        \"name\": \"undefined_var\",\n                        \"position\": SourcePosition(2, 5, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        errors = self.type_checker.check(ast)\n        self.assertGreater(len(errors), 0, \"Undefined symbol error should be detected\")\n        self.assertIn(\"undefined\", str(errors[0]).lower())\n\n    def test_missing_return(self):\n        \"\"\"Test detection of missing return in non-void functions\"\"\"\n        # Create a function with a non-void return type but no return statement\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"no_return\",\n                \"parameters\": [],\n                \"return_type\": {\"name\": \"int\"},\n                \"body\": [{\n                    \"node_type\": \"variable_declaration\",\n                    \"name\": \"x\",\n                    \"var_type\": {\"name\": \"int\"},\n                    \"init_value\": {\n                        \"node_type\": \"literal\",\n                        \"literal_type\": \"int\",\n                        \"value\": 42,\n                        \"position\": SourcePosition(2, 5, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        errors = self.type_checker.check(ast)\n        self.assertGreater(len(errors), 0, \"Missing return error should be detected\")\n        self.assertIn(\"return\", str(errors[0]).lower())\n\n    def test_option_type(self):\n        \"\"\"Test type checking with Option<T> types\"\"\"\n        # Create a function that returns an Option<int>\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"get_optional\",\n                \"parameters\": [],\n                \"return_type\": {\n                    \"name\": \"Option\",\n                    \"type_params\": [{\"name\": \"int\"}],\n                    \"position\": SourcePosition(1, 20, \"test.ae\")\n                },\n                \"body\": [{\n                    \"node_type\": \"return_statement\",\n                    \"value\": {\n                        \"node_type\": \"constructor_call\",\n                        \"name\": \"Some\",\n                        \"arguments\": [{\n                            \"node_type\": \"literal\",\n                            \"literal_type\": \"int\",\n                            \"value\": 42,\n                            \"position\": SourcePosition(2, 15, \"test.ae\")\n                        }],\n                        \"position\": SourcePosition(2, 12, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        errors = self.type_checker.check(ast)\n        self.assertEqual(len(errors), 0, \"Option<T> should be correctly type checked\")\n\n    def test_match_exhaustiveness(self):\n        \"\"\"Test that match expressions are checked for exhaustiveness\"\"\"\n        # Create a match expression on an Option<T> type\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"handle_option\",\n                \"parameters\": [{\n                    \"name\": \"opt\",\n                    \"param_type\": {\n                        \"name\": \"Option\",\n                        \"type_params\": [{\"name\": \"int\"}],\n                        \"position\": SourcePosition(1, 25, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(1, 20, \"test.ae\")\n                }],\n                \"return_type\": {\"name\": \"int\"},\n                \"body\": [{\n                    \"node_type\": \"match_statement\",\n                    \"subject\": {\n                        \"node_type\": \"identifier\",\n                        \"name\": \"opt\",\n                        \"position\": SourcePosition(2, 11, \"test.ae\")\n                    },\n                    \"branches\": [\n                        {\n                            \"pattern\": {\n                                \"node_type\": \"constructor_pattern\",\n                                \"name\": \"Some\",\n                                \"bindings\": [{\n                                    \"node_type\": \"binding_pattern\",\n                                    \"name\": \"value\",\n                                    \"position\": SourcePosition(3, 15, \"test.ae\")\n                                }],\n                                \"position\": SourcePosition(3, 5, \"test.ae\")\n                            },\n                            \"body\": {\n                                \"node_type\": \"return_statement\",\n                                \"value\": {\n                                    \"node_type\": \"identifier\",\n                                    \"name\": \"value\",\n                                    \"position\": SourcePosition(3, 25, \"test.ae\")\n                                },\n                                \"position\": SourcePosition(3, 18, \"test.ae\")\n                            },\n                            \"guard\": None\n                        }\n                        # Missing None case\n                    ],\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        errors = self.type_checker.check(ast)\n        self.assertGreater(len(errors), 0, \"Non-exhaustive match should be detected\")\n        self.assertIn(\"exhaustive\", str(errors[0]).lower())\n\n    def test_concurrent_task_types(self):\n        \"\"\"Test type checking with async/await and Task<T> types\"\"\"\n        # Create an async function returning a Task<string>\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"fetch_data\",\n                \"parameters\": [],\n                \"return_type\": {\n                    \"name\": \"Task\",\n                    \"type_params\": [{\"name\": \"string\"}],\n                    \"position\": SourcePosition(1, 20, \"test.ae\")\n                },\n                \"is_async\": True,\n                \"body\": [{\n                    \"node_type\": \"return_statement\",\n                    \"value\": {\n                        \"node_type\": \"literal\",\n                        \"literal_type\": \"string\",\n                        \"value\": \"data\",\n                        \"position\": SourcePosition(2, 12, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }, {\n                # Another function that awaits the first function\n                \"node_type\": \"function\",\n                \"name\": \"process_data\",\n                \"parameters\": [],\n                \"return_type\": {\"name\": \"string\"},\n                \"body\": [{\n                    \"node_type\": \"variable_declaration\",\n                    \"name\": \"data\",\n                    \"var_type\": {\"name\": \"string\"},\n                    \"init_value\": {\n                        \"node_type\": \"await_expression\",\n                        \"expression\": {\n                            \"node_type\": \"function_call\",\n                            \"name\": \"fetch_data\",\n                            \"arguments\": [],\n                            \"position\": SourcePosition(2, 17, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(2, 11, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }, {\n                    \"node_type\": \"return_statement\",\n                    \"value\": {\n                        \"node_type\": \"identifier\",\n                        \"name\": \"data\",\n                        \"position\": SourcePosition(3, 12, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(3, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        errors = self.type_checker.check(ast)\n        self.assertEqual(len(errors), 0, \"Concurrent types should be correctly checked\")\n\n    def test_result_type(self):\n        \"\"\"Test type checking with Result<T, E> types\"\"\"\n        # Create a function returning Result<int, string>\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"divide\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 15, \"test.ae\")\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 25, \"test.ae\")\n                    }\n                ],\n                \"return_type\": {\n                    \"name\": \"Result\",\n                    \"type_params\": [{\"name\": \"int\"}, {\"name\": \"string\"}],\n                    \"position\": SourcePosition(1, 35, \"test.ae\")\n                },\n                \"body\": [{\n                    \"node_type\": \"if_statement\",\n                    \"condition\": {\n                        \"node_type\": \"binary_operation\",\n                        \"operator\": \"==\",\n                        \"left\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"b\",\n                            \"position\": SourcePosition(2, 9, \"test.ae\")\n                        },\n                        \"right\": {\n                            \"node_type\": \"literal\",\n                            \"literal_type\": \"int\",\n                            \"value\": 0,\n                            \"position\": SourcePosition(2, 14, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(2, 11, \"test.ae\")\n                    },\n                    \"then_branch\": [{\n                        \"node_type\": \"return_statement\",\n                        \"value\": {\n                            \"node_type\": \"constructor_call\",\n                            \"name\": \"Err\",\n                            \"arguments\": [{\n                                \"node_type\": \"literal\",\n                                \"literal_type\": \"string\",\n                                \"value\": \"Division by zero\",\n                                \"position\": SourcePosition(3, 20, \"test.ae\")\n                            }],\n                            \"position\": SourcePosition(3, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(3, 9, \"test.ae\")\n                    }],\n                    \"else_branch\": [{\n                        \"node_type\": \"return_statement\",\n                        \"value\": {\n                            \"node_type\": \"constructor_call\",\n                            \"name\": \"Ok\",\n                            \"arguments\": [{\n                                \"node_type\": \"binary_operation\",\n                                \"operator\": \"/\",\n                                \"left\": {\n                                    \"node_type\": \"identifier\",\n                                    \"name\": \"a\",\n                                    \"position\": SourcePosition(5, 19, \"test.ae\")\n                                },\n                                \"right\": {\n                                    \"node_type\": \"identifier\",\n                                    \"name\": \"b\",\n                                    \"position\": SourcePosition(5, 23, \"test.ae\")\n                                },\n                                \"position\": SourcePosition(5, 21, \"test.ae\")\n                            }],\n                            \"position\": SourcePosition(5, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(5, 9, \"test.ae\")\n                    }],\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        errors = self.type_checker.check(ast)\n        self.assertEqual(len(errors), 0, \"Result<T, E> should be correctly type checked\")\n\n    def test_dsl_pattern(self):\n        \"\"\"Test type checking with DSL-like patterns\"\"\"\n        # Create a DSL-like pattern for a query builder\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"QueryDSL\",\n            \"children\": [{\n                \"node_type\": \"struct\",\n                \"name\": \"Query\",\n                \"fields\": [\n                    {\n                        \"node_type\": \"field\",\n                        \"name\": \"table\",\n                        \"field_type\": {\"name\": \"string\"},\n                        \"position\": SourcePosition(2, 5, \"test.ae\")\n                    },\n                    {\n                        \"node_type\": \"field\",\n                        \"name\": \"conditions\",\n                        \"field_type\": {\"name\": \"string\"},\n                        \"position\": SourcePosition(3, 5, \"test.ae\")\n                    }\n                ],\n                \"methods\": [{\n                    \"node_type\": \"function\",\n                    \"name\": \"where\",\n                    \"parameters\": [\n                        {\n                            \"name\": \"self\",\n                            \"param_type\": {\"name\": \"Query\"},\n                            \"position\": SourcePosition(5, 15, \"test.ae\")\n                        },\n                        {\n                            \"name\": \"condition\",\n                            \"param_type\": {\"name\": \"string\"},\n                            \"position\": SourcePosition(5, 25, \"test.ae\")\n                        }\n                    ],\n                    \"return_type\": {\"name\": \"Query\"},\n                    \"body\": [{\n                        \"node_type\": \"return_statement\",\n                        \"value\": {\n                            \"node_type\": \"constructor_call\",\n                            \"name\": \"Query\",\n                            \"arguments\": [\n                                {\n                                    \"node_type\": \"member_access\",\n                                    \"object\": {\n                                        \"node_type\": \"identifier\",\n                                        \"name\": \"self\",\n                                        \"position\": SourcePosition(6, 16, \"test.ae\")\n                                    },\n                                    \"member\": \"table\",\n                                    \"position\": SourcePosition(6, 21, \"test.ae\")\n                                },\n                                {\n                                    \"node_type\": \"binary_operation\",\n                                    \"operator\": \"+\",\n                                    \"left\": {\n                                        \"node_type\": \"member_access\",\n                                        \"object\": {\n                                            \"node_type\": \"identifier\",\n                                            \"name\": \"self\",\n                                            \"position\": SourcePosition(6, 28, \"test.ae\")\n                                        },\n                                        \"member\": \"conditions\",\n                                        \"position\": SourcePosition(6, 33, \"test.ae\")\n                                    },\n                                    \"right\": {\n                                        \"node_type\": \"identifier\",\n                                        \"name\": \"condition\",\n                                        \"position\": SourcePosition(6, 50, \"test.ae\")\n                                    },\n                                    \"position\": SourcePosition(6, 48, \"test.ae\")\n                                }\n                            ],\n                            \"position\": SourcePosition(6, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(6, 9, \"test.ae\")\n                    }],\n                    \"position\": SourcePosition(5, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }, {\n                \"node_type\": \"function\",\n                \"name\": \"from\",\n                \"parameters\": [{\n                    \"name\": \"table\",\n                    \"param_type\": {\"name\": \"string\"},\n                    \"position\": SourcePosition(10, 15, \"test.ae\")\n                }],\n                \"return_type\": {\"name\": \"Query\"},\n                \"body\": [{\n                    \"node_type\": \"return_statement\",\n                    \"value\": {\n                        \"node_type\": \"constructor_call\",\n                        \"name\": \"Query\",\n                        \"arguments\": [\n                            {\n                                \"node_type\": \"identifier\",\n                                \"name\": \"table\",\n                                \"position\": SourcePosition(11, 16, \"test.ae\")\n                            },\n                            {\n                                \"node_type\": \"literal\",\n                                \"literal_type\": \"string\",\n                                \"value\": \"\",\n                                \"position\": SourcePosition(11, 23, \"test.ae\")\n                            }\n                        ],\n                        \"position\": SourcePosition(11, 12, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(11, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(10, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        errors = self.type_checker.check(ast)\n        self.assertEqual(len(errors), 0, \"DSL pattern should type check correctly\")\n\nif __name__ == \"__main__\":\n    unittest.main()", "size": 21715, "lastModified": 1741357774.7884421, "moduleContext": "tests", "structure": {"classes": ["TestSemanticAnalysis"], "functions": ["test_concurrent_task_types", "test_result_type", "test_match_exhaustiveness", "test_missing_return", "setUp", "test_option_type", "test_dsl_pattern", "test_incompatible_types", "test_undefined_symbol", "test_basic_type_checking"], "imports": ["TypeChecker", "unittest", "src", "SymbolTable", "SourcePosition"]}, "stats": {"line_count": 508, "function_count": 10, "class_count": 1, "complexity_estimate": 17}, "contentHash": "66e3eaa2c22ddb2e450459c7347b659a"}
{"filePath": "tests/alt_test.py", "language": "Python", "content": "import unittest\nfrom src.lexer.lexer import lex\nfrom src.parser.parser import AegisParser\nfrom src.compiler.type_checker import TypeChecker\nfrom src.compiler.code_generator import CodeGenerator\n\nclass CompilerTest(unittest.TestCase):\n    def setUp(self):\n        self.source_code = \"\"\"\n        module TestModule:\n            struct User:\n                name: string\n                age: int\n\n            fn create_user(name: string) -> User:\n                return User(name, 25)\n        \"\"\"\n\n    def test_lexer(self):\n        tokens = lex(self.source_code)\n        self.assertTrue(len(tokens) > 0)\n\n    def test_parser(self):\n        tokens = lex(self.source_code)\n        parser = AegisParser(tokens)\n        ast = parser.parse()\n        self.assertEqual(ast.node_type, \"Module\")\n\n    def test_type_checker(self):\n        tokens = lex(self.source_code)\n        parser = AegisParser(tokens)\n        ast = parser.parse()\n        type_checker = TypeChecker(ast)\n        self.assertEqual(type_checker.check(), \"Semantic Analysis Passed\")\n\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "size": 1086, "lastModified": 1741346469.889497, "moduleContext": "tests", "structure": {"classes": ["CompilerTest"], "functions": ["test_parser", "test_type_checker", "test_lexer", "setUp"], "imports": ["TypeChecker", "CodeGenerator", "unittest", "src", "lex", "AegisParser"]}, "stats": {"line_count": 39, "function_count": 4, "class_count": 1, "complexity_estimate": 3}, "contentHash": "dec4b0bc0e3907f99a00ee32c63eec09"}
{"filePath": "tests/test_codegen.py", "language": "Python", "content": "\"\"\"\nTest suite for the LLVM code generation in Aegis.\n\nTests the generation of LLVM IR code for various Aegis language constructs,\nensuring that the output is correct and can be compiled/executed.\n\"\"\"\n\nimport unittest\nimport tempfile\nimport os\nimport subprocess\nfrom src.codegen.llvm_generator import LLVMGenerator, WasmGenerator\nfrom src.parser.aeigix_ast_visitor import SourcePosition, AegisASTVisitor\nfrom llvmlite import binding\n\n# Initialize LLVM\nbinding.initialize()\nbinding.initialize_native_target()\nbinding.initialize_native_asmprinter()\n\nclass TestLLVMCodeGen(unittest.TestCase):\n    def setUp(self):\n        # Create a simple mock for the target machine\n        self.target = binding.Target.from_default_triple()\n        self.target_machine = self.target.create_target_machine()\n    \n    def test_basic_function_generation(self):\n        \"\"\"Test generation of a basic function\"\"\"\n        # Create a simple AST for a function that returns an integer\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"add\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 15, \"test.ae\")\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 25, \"test.ae\")\n                    }\n                ],\n                \"return_type\": {\"name\": \"int\"},\n                \"body\": [{\n                    \"node_type\": \"return_statement\",\n                    \"value\": {\n                        \"node_type\": \"binary_operation\",\n                        \"operator\": \"+\",\n                        \"left\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"a\",\n                            \"position\": SourcePosition(2, 12, \"test.ae\")\n                        },\n                        \"right\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"b\",\n                            \"position\": SourcePosition(2, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(2, 14, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        # Generate LLVM IR\n        generator = LLVMGenerator(ast)\n        ir_code = generator.generate()\n        \n        # Verify the IR is valid\n        module = binding.parse_assembly(ir_code)\n        module.verify()\n        \n        # Check for key elements in the generated IR\n        self.assertIn(\"define\", ir_code)\n        self.assertIn(\"add\", ir_code)\n        self.assertIn(\"add\", ir_code)\n        \n    def test_struct_generation(self):\n        \"\"\"Test generation of a struct with fields\"\"\"\n        # Create an AST for a struct definition\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"struct\",\n                \"name\": \"Point\",\n                \"fields\": [\n                    {\n                        \"node_type\": \"field\",\n                        \"name\": \"x\",\n                        \"field_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(2, 5, \"test.ae\")\n                    },\n                    {\n                        \"node_type\": \"field\",\n                        \"name\": \"y\",\n                        \"field_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(3, 5, \"test.ae\")\n                    }\n                ],\n                \"methods\": [],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        # Generate LLVM IR\n        generator = LLVMGenerator(ast)\n        ir_code = generator.generate()\n        \n        # Verify the IR is valid\n        module = binding.parse_assembly(ir_code)\n        module.verify()\n        \n        # Check for struct type definition\n        self.assertIn(\"type %Point\", ir_code.replace(\" \", \"\"))\n        \n    def test_conditional_code_generation(self):\n        \"\"\"Test generation of if-else statements\"\"\"\n        # Create an AST with an if-else statement\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"max\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 15, \"test.ae\")\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 25, \"test.ae\")\n                    }\n                ],\n                \"return_type\": {\"name\": \"int\"},\n                \"body\": [{\n                    \"node_type\": \"if_statement\",\n                    \"condition\": {\n                        \"node_type\": \"binary_operation\",\n                        \"operator\": \">\",\n                        \"left\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"a\",\n                            \"position\": SourcePosition(2, 9, \"test.ae\")\n                        },\n                        \"right\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"b\",\n                            \"position\": SourcePosition(2, 13, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(2, 11, \"test.ae\")\n                    },\n                    \"then_branch\": [{\n                        \"node_type\": \"return_statement\",\n                        \"value\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"a\",\n                            \"position\": SourcePosition(3, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(3, 9, \"test.ae\")\n                    }],\n                    \"else_branch\": [{\n                        \"node_type\": \"return_statement\",\n                        \"value\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"b\",\n                            \"position\": SourcePosition(5, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(5, 9, \"test.ae\")\n                    }],\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        # Generate LLVM IR\n        generator = LLVMGenerator(ast)\n        ir_code = generator.generate()\n        \n        # Verify the IR contains branching instructions\n        self.assertIn(\"icmp\", ir_code)\n        self.assertIn(\"br\", ir_code)\n        \n    def test_option_type_generation(self):\n        \"\"\"Test generation of Option<T> pattern\"\"\"\n        # Create an AST with Option<T> usage\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"find_value\",\n                \"parameters\": [\n                    {\n                        \"name\": \"key\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 15, \"test.ae\")\n                    }\n                ],\n                \"return_type\": {\n                    \"name\": \"Option\",\n                    \"type_params\": [{\"name\": \"int\"}],\n                    \"position\": SourcePosition(1, 35, \"test.ae\")\n                },\n                \"body\": [{\n                    \"node_type\": \"if_statement\",\n                    \"condition\": {\n                        \"node_type\": \"binary_operation\",\n                        \"operator\": \">\",\n                        \"left\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"key\",\n                            \"position\": SourcePosition(2, 9, \"test.ae\")\n                        },\n                        \"right\": {\n                            \"node_type\": \"literal\",\n                            \"literal_type\": \"int\",\n                            \"value\": 0,\n                            \"position\": SourcePosition(2, 15, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(2, 13, \"test.ae\")\n                    },\n                    \"then_branch\": [{\n                        \"node_type\": \"return_statement\",\n                        \"value\": {\n                            \"node_type\": \"constructor_call\",\n                            \"name\": \"Some\",\n                            \"arguments\": [{\n                                \"node_type\": \"identifier\",\n                                \"name\": \"key\",\n                                \"position\": SourcePosition(3, 21, \"test.ae\")\n                            }],\n                            \"position\": SourcePosition(3, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(3, 9, \"test.ae\")\n                    }],\n                    \"else_branch\": [{\n                        \"node_type\": \"return_statement\",\n                        \"value\": {\n                            \"node_type\": \"constructor_call\",\n                            \"name\": \"None\",\n                            \"arguments\": [],\n                            \"position\": SourcePosition(5, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(5, 9, \"test.ae\")\n                    }],\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        # Generate LLVM IR\n        generator = LLVMGenerator(ast)\n        ir_code = generator.generate()\n        \n        # Check if the IR compiles successfully\n        module = binding.parse_assembly(ir_code)\n        module.verify()\n        \n    def test_loop_generation(self):\n        \"\"\"Test generation of loop constructs\"\"\"\n        # Create an AST with a while loop\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"sum_to_n\",\n                \"parameters\": [\n                    {\n                        \"name\": \"n\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 15, \"test.ae\")\n                    }\n                ],\n                \"return_type\": {\"name\": \"int\"},\n                \"body\": [\n                    {\n                        \"node_type\": \"variable_declaration\",\n                        \"name\": \"sum\",\n                        \"var_type\": {\"name\": \"int\"},\n                        \"init_value\": {\n                            \"node_type\": \"literal\",\n                            \"literal_type\": \"int\",\n                            \"value\": 0,\n                            \"position\": SourcePosition(2, 14, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(2, 5, \"test.ae\")\n                    },\n                    {\n                        \"node_type\": \"variable_declaration\",\n                        \"name\": \"i\",\n                        \"var_type\": {\"name\": \"int\"},\n                        \"init_value\": {\n                            \"node_type\": \"literal\",\n                            \"literal_type\": \"int\",\n                            \"value\": 1,\n                            \"position\": SourcePosition(3, 12, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(3, 5, \"test.ae\")\n                    },\n                    {\n                        \"node_type\": \"while_statement\",\n                        \"condition\": {\n                            \"node_type\": \"binary_operation\",\n                            \"operator\": \"<=\",\n                            \"left\": {\n                                \"node_type\": \"identifier\",\n                                \"name\": \"i\",\n                                \"position\": SourcePosition(4, 12, \"test.ae\")\n                            },\n                            \"right\": {\n                                \"node_type\": \"identifier\",\n                                \"name\": \"n\",\n                                \"position\": SourcePosition(4, 17, \"test.ae\")\n                            },\n                            \"position\": SourcePosition(4, 14, \"test.ae\")\n                        },\n                        \"body\": [\n                            {\n                                \"node_type\": \"expression_statement\",\n                                \"expression\": {\n                                    \"node_type\": \"binary_operation\",\n                                    \"operator\": \"=\",\n                                    \"left\": {\n                                        \"node_type\": \"identifier\",\n                                        \"name\": \"sum\",\n                                        \"position\": SourcePosition(5, 9, \"test.ae\")\n                                    },\n                                    \"right\": {\n                                        \"node_type\": \"binary_operation\",\n                                        \"operator\": \"+\",\n                                        \"left\": {\n                                            \"node_type\": \"identifier\",\n                                            \"name\": \"sum\",\n                                            \"position\": SourcePosition(5, 15, \"test.ae\")\n                                        },\n                                        \"right\": {\n                                            \"node_type\": \"identifier\",\n                                            \"name\": \"i\",\n                                            \"position\": SourcePosition(5, 21, \"test.ae\")\n                                        },\n                                        \"position\": SourcePosition(5, 19, \"test.ae\")\n                                    },\n                                    \"position\": SourcePosition(5, 13, \"test.ae\")\n                                },\n                                \"position\": SourcePosition(5, 9, \"test.ae\")\n                            },\n                            {\n                                \"node_type\": \"expression_statement\",\n                                \"expression\": {\n                                    \"node_type\": \"binary_operation\",\n                                    \"operator\": \"=\",\n                                    \"left\": {\n                                        \"node_type\": \"identifier\",\n                                        \"name\": \"i\",\n                                        \"position\": SourcePosition(6, 9, \"test.ae\")\n                                    },\n                                    \"right\": {\n                                        \"node_type\": \"binary_operation\",\n                                        \"operator\": \"+\",\n                                        \"left\": {\n                                            \"node_type\": \"identifier\",\n                                            \"name\": \"i\",\n                                            \"position\": SourcePosition(6, 13, \"test.ae\")\n                                        },\n                                        \"right\": {\n                                            \"node_type\": \"literal\",\n                                            \"literal_type\": \"int\",\n                                            \"value\": 1,\n                                            \"position\": SourcePosition(6, 17, \"test.ae\")\n                                        },\n                                        \"position\": SourcePosition(6, 15, \"test.ae\")\n                                    },\n                                    \"position\": SourcePosition(6, 11, \"test.ae\")\n                                },\n                                \"position\": SourcePosition(6, 9, \"test.ae\")\n                            }\n                        ],\n                        \"position\": SourcePosition(4, 5, \"test.ae\")\n                    },\n                    {\n                        \"node_type\": \"return_statement\",\n                        \"value\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"sum\",\n                            \"position\": SourcePosition(8, 12, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(8, 5, \"test.ae\")\n                    }\n                ],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        # Generate LLVM IR\n        generator = LLVMGenerator(ast)\n        ir_code = generator.generate()\n        \n        # Verify that the IR contains loop constructs\n        self.assertIn(\"br\", ir_code)\n        self.assertIn(\"icmp\", ir_code)\n        \n    def test_result_type_generation(self):\n        \"\"\"Test generation of Result<T, E> pattern\"\"\"\n        # Create an AST with Result<T, E> usage\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"safe_divide\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 15, \"test.ae\")\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 25, \"test.ae\")\n                    }\n                ],\n                \"return_type\": {\n                    \"name\": \"Result\",\n                    \"type_params\": [{\"name\": \"int\"}, {\"name\": \"string\"}],\n                    \"position\": SourcePosition(1, 35, \"test.ae\")\n                },\n                \"body\": [{\n                    \"node_type\": \"if_statement\",\n                    \"condition\": {\n                        \"node_type\": \"binary_operation\",\n                        \"operator\": \"==\",\n                        \"left\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"b\",\n                            \"position\": SourcePosition(2, 9, \"test.ae\")\n                        },\n                        \"right\": {\n                            \"node_type\": \"literal\",\n                            \"literal_type\": \"int\",\n                            \"value\": 0,\n                            \"position\": SourcePosition(2, 14, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(2, 11, \"test.ae\")\n                    },\n                    \"then_branch\": [{\n                        \"node_type\": \"return_statement\",\n                        \"value\": {\n                            \"node_type\": \"constructor_call\",\n                            \"name\": \"Err\",\n                            \"arguments\": [{\n                                \"node_type\": \"literal\",\n                                \"literal_type\": \"string\",\n                                \"value\": \"Division by zero\",\n                                \"position\": SourcePosition(3, 20, \"test.ae\")\n                            }],\n                            \"position\": SourcePosition(3, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(3, 9, \"test.ae\")\n                    }],\n                    \"else_branch\": [{\n                        \"node_type\": \"return_statement\",\n                        \"value\": {\n                            \"node_type\": \"constructor_call\",\n                            \"name\": \"Ok\",\n                            \"arguments\": [{\n                                \"node_type\": \"binary_operation\",\n                                \"operator\": \"/\",\n                                \"left\": {\n                                    \"node_type\": \"identifier\",\n                                    \"name\": \"a\",\n                                    \"position\": SourcePosition(5, 19, \"test.ae\")\n                                },\n                                \"right\": {\n                                    \"node_type\": \"identifier\",\n                                    \"name\": \"b\",\n                                    \"position\": SourcePosition(5, 23, \"test.ae\")\n                                },\n                                \"position\": SourcePosition(5, 21, \"test.ae\")\n                            }],\n                            \"position\": SourcePosition(5, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(5, 9, \"test.ae\")\n                    }],\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        # Generate LLVM IR\n        generator = LLVMGenerator(ast)\n        ir_code = generator.generate()\n        \n        # Verify the IR is valid\n        module = binding.parse_assembly(ir_code)\n        module.verify()\n        \n    def test_match_expression_generation(self):\n        \"\"\"Test generation of match expression\"\"\"\n        # Create an AST with a match expression\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"Test\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"process_option\",\n                \"parameters\": [\n                    {\n                        \"name\": \"opt\",\n                        \"param_type\": {\n                            \"name\": \"Option\",\n                            \"type_params\": [{\"name\": \"int\"}],\n                            \"position\": SourcePosition(1, 25, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(1, 20, \"test.ae\")\n                    }\n                ],\n                \"return_type\": {\"name\": \"int\"},\n                \"body\": [{\n                    \"node_type\": \"match_statement\",\n                    \"subject\": {\n                        \"node_type\": \"identifier\",\n                        \"name\": \"opt\",\n                        \"position\": SourcePosition(2, 11, \"test.ae\")\n                    },\n                    \"branches\": [\n                        {\n                            \"pattern\": {\n                                \"node_type\": \"constructor_pattern\",\n                                \"name\": \"Some\",\n                                \"bindings\": [{\n                                    \"node_type\": \"binding_pattern\",\n                                    \"name\": \"value\",\n                                    \"position\": SourcePosition(3, 15, \"test.ae\")\n                                }],\n                                \"position\": SourcePosition(3, 5, \"test.ae\")\n                            },\n                            \"body\": {\n                                \"node_type\": \"return_statement\",\n                                \"value\": {\n                                    \"node_type\": \"identifier\",\n                                    \"name\": \"value\",\n                                    \"position\": SourcePosition(3, 25, \"test.ae\")\n                                },\n                                \"position\": SourcePosition(3, 18, \"test.ae\")\n                            },\n                            \"guard\": None\n                        },\n                        {\n                            \"pattern\": {\n                                \"node_type\": \"constructor_pattern\",\n                                \"name\": \"None\",\n                                \"bindings\": [],\n                                \"position\": SourcePosition(4, 5, \"test.ae\")\n                            },\n                            \"body\": {\n                                \"node_type\": \"return_statement\",\n                                \"value\": {\n                                    \"node_type\": \"literal\",\n                                    \"literal_type\": \"int\",\n                                    \"value\": 0,\n                                    \"position\": SourcePosition(4, 25, \"test.ae\")\n                                },\n                                \"position\": SourcePosition(4, 18, \"test.ae\")\n                            },\n                            \"guard\": None\n                        }\n                    ],\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        # Generate LLVM IR\n        generator = LLVMGenerator(ast)\n        ir_code = generator.generate()\n        \n        # Verify the IR contains pattern matching constructs\n        self.assertIn(\"switch\", ir_code)\n        \n    def test_wasm_generation(self):\n        \"\"\"Test WebAssembly compatible IR generation\"\"\"\n        # Create a simple AST\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"WasmTest\",\n            \"children\": [{\n                \"node_type\": \"function\",\n                \"name\": \"add\",\n                \"parameters\": [\n                    {\n                        \"name\": \"a\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 15, \"test.ae\")\n                    },\n                    {\n                        \"name\": \"b\",\n                        \"param_type\": {\"name\": \"int\"},\n                        \"position\": SourcePosition(1, 25, \"test.ae\")\n                    }\n                ],\n                \"return_type\": {\"name\": \"int\"},\n                \"body\": [{\n                    \"node_type\": \"return_statement\",\n                    \"value\": {\n                        \"node_type\": \"binary_operation\",\n                        \"operator\": \"+\",\n                        \"left\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"a\",\n                            \"position\": SourcePosition(2, 12, \"test.ae\")\n                        },\n                        \"right\": {\n                            \"node_type\": \"identifier\",\n                            \"name\": \"b\",\n                            \"position\": SourcePosition(2, 16, \"test.ae\")\n                        },\n                        \"position\": SourcePosition(2, 14, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(2, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        # Generate WebAssembly-compatible IR\n        generator = WasmGenerator(ast)\n        ir_code = generator.generate()\n        \n        # Verify that the module has WASM target triple\n        self.assertIn(\"wasm32-unknown-unknown\", ir_code)\n        \n        # Verify that int types are 32-bit (WebAssembly prefers 32-bit integers)\n        self.assertIn(\"i32\", ir_code)\n        \n    def test_dsl_pattern_generation(self):\n        \"\"\"Test generation of DSL-like pattern\"\"\"\n        # Create an AST with a DSL-like pattern for a query builder\n        ast = {\n            \"node_type\": \"module\",\n            \"name\": \"QueryDSL\",\n            \"children\": [{\n                \"node_type\": \"struct\",\n                \"name\": \"Query\",\n                \"fields\": [\n                    {\n                        \"node_type\": \"field\",\n                        \"name\": \"table\",\n                        \"field_type\": {\"name\": \"string\"},\n                        \"position\": SourcePosition(2, 5, \"test.ae\")\n                    }\n                ],\n                \"methods\": [],\n                \"position\": SourcePosition(1, 1, \"test.ae\")\n            }, {\n                \"node_type\": \"function\",\n                \"name\": \"select\",\n                \"parameters\": [{\n                    \"name\": \"fields\",\n                    \"param_type\": {\"name\": \"string\"},\n                    \"position\": SourcePosition(5, 15, \"test.ae\")\n                }],\n                \"return_type\": {\"name\": \"Query\"},\n                \"body\": [{\n                    \"node_type\": \"variable_declaration\",\n                    \"name\": \"query\",\n                    \"var_type\": {\"name\": \"Query\"},\n                    \"init_value\": {\n                        \"node_type\": \"constructor_call\",\n                        \"name\": \"Query\",\n                        \"arguments\": [{\n                            \"node_type\": \"literal\",\n                            \"literal_type\": \"string\",\n                            \"value\": \"\",\n                            \"position\": SourcePosition(6, 20, \"test.ae\")\n                        }],\n                        \"position\": SourcePosition(6, 14, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(6, 5, \"test.ae\")\n                }, {\n                    \"node_type\": \"return_statement\",\n                    \"value\": {\n                        \"node_type\": \"identifier\",\n                        \"name\": \"query\",\n                        \"position\": SourcePosition(7, 12, \"test.ae\")\n                    },\n                    \"position\": SourcePosition(7, 5, \"test.ae\")\n                }],\n                \"position\": SourcePosition(5, 1, \"test.ae\")\n            }],\n            \"position\": SourcePosition(1, 1, \"test.ae\")\n        }\n        \n        # Generate LLVM IR for DSL pattern\n        generator = LLVMGenerator(ast)\n        ir_code = generator.generate()\n        \n        # Verify the IR is valid\n        module = binding.parse_assembly(ir_code)\n        module.verify()\n        \n        # Verify struct type and function\n        self.assertIn(\"type %Query\", ir_code.replace(\" \", \"\"))\n        self.assertIn(\"define\", ir_code)\n        self.assertIn(\"select\", ir_code)\n\nif __name__ == \"__main__\":\n    unittest.main()", "size": 30654, "lastModified": 1741358176.8036337, "moduleContext": "tests", "structure": {"classes": ["TestLLVMCodeGen"], "functions": ["test_struct_generation", "test_result_type_generation", "test_wasm_generation", "test_basic_function_generation", "test_loop_generation", "test_conditional_code_generation", "test_dsl_pattern_generation", "setUp", "test_match_expression_generation", "test_option_type_generation"], "imports": ["subprocess", "SourcePosition", "unittest", "src", "llvmlite", "LLVMGenerator", "os", "binding", "tempfile"]}, "stats": {"line_count": 732, "function_count": 10, "class_count": 1, "complexity_estimate": 23}, "contentHash": "17e82504229081d1838efc9d5ab061e6"}
{"filePath": "utils/logger.py", "language": "Python", "content": "# utils/logger.py\nimport logging\n\n\ndef get_logger(name):\n    logger = logging.getLogger(name)\n    logger_format = \"%(asctime)s [%(levelname)s] %(message)s\"\n    logging.basicConfig(\n        level=logging.DEBUG, format=\"%(asctime)s [%(levelname)s]: %(message)s\"\n    )\n    return logging.getLogger(name)\n", "size": 301, "lastModified": 1741345565.6478825, "moduleContext": "utils", "structure": {"classes": [], "functions": ["get_logger"], "imports": ["logging"]}, "stats": {"line_count": 12, "function_count": 1, "class_count": 0, "complexity_estimate": 2}, "contentHash": "857d44cb443f92bddd218ebd08807e6d"}
{"filePath": "examples/hello.ae", "language": "Aegis", "content": "module HelloWorld:\n    fn main() -> int:\n        return 0\n", "size": 58, "lastModified": 1741345565.6444752, "moduleContext": "examples", "structure": {"modules": ["HelloWorld"], "structs": [], "functions": ["main"], "imports": [], "types": [], "sections": [], "function_signatures": ["main() -> int"]}, "stats": {"line_count": 4, "function_count": 1, "class_count": 0, "complexity_estimate": 2}, "contentHash": "1c4f1b5620e4cdd7d589f0d056e7b35b"}
{"filePath": "examples/demo_security.ae", "language": "Aegis", "content": "import pandas as pd\nimport ace_tools as tools\n\n# from security.security_audit import AegisLangSecurityAudit\n\ndef main():\n    # Suppose we have AI-generated code or enterprise code to check\n    generated_enterprise_code = \"module ECommercePlatform: ...\"\n    optimized_ai_code = \"module ECommercePlatform: ... optimized ...\"\n\n    security_audit = AegisLangSecurityAudit([generated_enterprise_code, optimized_ai_code])\n    audit_results = security_audit.run_audit()\n\n    df_security_audit = pd.DataFrame([\n        {\"Stage\": \"Security Scan\", \"Result\": \", \".join(audit_results[\"Security Scan\"])},\n        {\"Stage\": \"Code Integrity Check\", \"Result\": \", \".join(audit_results[\"Code Integrity Hash\"])}\n    ])\n    tools.display_dataframe_to_user(name=\"AegisLang Security Audit Results\", dataframe=df_security_audit)\n\n    print(\"Security audit demo complete!\")\n\nif __name__ == \"__main__\":\n    main()\n", "size": 889, "lastModified": 1741345565.643735, "moduleContext": "examples", "structure": {"modules": ["ECommercePlatform", "ECommercePlatform"], "structs": [], "functions": [], "imports": ["pandas as pd", "ace_tools as tools", "AegisLangSecurityAudit"], "types": [], "sections": [], "function_signatures": []}, "stats": {"line_count": 24, "function_count": 0, "class_count": 0, "complexity_estimate": 2}, "contentHash": "35e1bfb5f7be9779c98dcb7ba0057971"}
{"filePath": "examples/user.ae", "language": "Aegis", "content": "module Example:\n    struct User:\n        name: string\n        age: int\n\n    fn get_user(name: string) -> User:\n        return User(name, 25)\n", "size": 141, "lastModified": 1741345565.6449695, "moduleContext": "examples", "structure": {"modules": ["Example"], "structs": ["User"], "functions": ["get_user"], "imports": [], "types": [], "sections": [], "function_signatures": ["get_user(name: string) -> User"]}, "stats": {"line_count": 8, "function_count": 1, "class_count": 0, "complexity_estimate": 2}, "contentHash": "005a188f25f301ffd92a7b79a3b30916"}
{"filePath": "examples/demo_stdlib.ae", "language": "Aegis", "content": "\"\"\"\nDemonstration of registering and displaying the AegisLang standard libraries.\n\"\"\"\n\nimport pandas as pd\nimport ace_tools as tools\n\n# from stdlib.stdlib import StandardLibrary, ExtendedStandardLibrary, FullStandardLibrary\n\ndef main():\n    # 1) Full standard library\n    full_std_lib = FullStandardLibrary()\n    full_std_lib.register_builtin_functions()\n    full_std_lib.register_extended_functions()\n    full_std_lib.register_advanced_functions()\n    complete_library = full_std_lib.get_library()\n\n    df_complete_std_lib = pd.DataFrame([\n        {\"Function\": key, \"Parameters\": str(value[\"params\"]), \"Return Type\": value[\"return\"]}\n        for key, value in complete_library.items()\n    ])\n    tools.display_dataframe_to_user(name=\"Complete Standard Library for AegisLang\", dataframe=df_complete_std_lib)\n\n    # 2) Extended standard library\n    ext_std_lib = ExtendedStandardLibrary()\n    ext_std_lib.register_builtin_functions()\n    ext_std_lib.register_extended_functions()\n    extended_library = ext_std_lib.get_library()\n\n    df_extended_std_lib = pd.DataFrame([\n        {\"Function\": key, \"Parameters\": str(value[\"params\"]), \"Return Type\": value[\"return\"]}\n        for key, value in extended_library.items()\n    ])\n    tools.display_dataframe_to_user(name=\"Extended Standard Library Functions for AegisLang\", dataframe=df_extended_std_lib)\n\n    # 3) Basic standard library\n    std_lib = StandardLibrary()\n    std_lib.register_builtin_functions()\n    standard_library = std_lib.get_library()\n\n    df_std_lib = pd.DataFrame([\n        {\"Function\": key, \"Parameters\": str(value[\"params\"]), \"Return Type\": value[\"return\"]}\n        for key, value in standard_library.items()\n    ])\n    tools.display_dataframe_to_user(name=\"AegisLang Standard Library Functions\", dataframe=df_std_lib)\n\n    print(\"Stdlib demo complete!\")\n\nif __name__ == \"__main__\":\n    main()\n", "size": 1861, "lastModified": 1741345565.644013, "moduleContext": "examples", "structure": {"modules": [], "structs": [], "functions": [], "imports": ["pandas as pd", "ace_tools as tools", "StandardLibrary, ExtendedStandardLibrary, FullStandardLibrary"], "types": [], "sections": [], "function_signatures": []}, "stats": {"line_count": 51, "function_count": 0, "class_count": 0, "complexity_estimate": 10}, "contentHash": "220f14934d624dbc901ece24a731c029"}
{"filePath": "examples/demo_compiler.ae", "language": "Aegis", "content": "\"\"\"\nDemonstration of AegisLang compiler steps:\n1. Lex source code\n2. Parse into AST\n3. Type-check\n4. Generate LLVM IR\n5. JIT compile & execute\nDisplays intermediate data using pandas and ace_tools.\n\"\"\"\n\nimport pandas as pd\nimport ace_tools as tools  # If you truly need to display DataFrames in your environment\n\nfrom compiler.aegis_compiler import (\n    lex, AegisParser, TypeChecker, CodeGenerator, JITCompiler\n)\n\n# Example AegisLang source\ntest_code = \"\"\"\nmodule UserSystem:\n    struct User:\n        name: string\n        age: int\n\n    fn create_user(name: string, age: int) -> User:\n        return User(name, age)\n\"\"\"\n\n# 1) Lexing\ntokens = lex(test_code)\ndf_tokens = pd.DataFrame(tokens, columns=[\"Token Type\", \"Value\"])\ntools.display_dataframe_to_user(\n    name=\"Lexer Tokens for AegisLang\",\n    dataframe=df_tokens\n)\n\n# 2) Parsing -> AST\nparser = AegisParser(tokens)\nast = parser.parse()\ndf_ast = pd.DataFrame([\n    {\"Node Type\": node.node_type, \"Value\": node.value, \"Children\": len(node.children)}\n    for node in [ast] + ast.children\n])\ntools.display_dataframe_to_user(\n    name=\"AST Representation of AegisLang Code\",\n    dataframe=df_ast\n)\n\n# 3) Type Checking\ntype_checker = TypeChecker(ast)\ntype_check_result = type_checker.check()\ndf_result = pd.DataFrame([{\"Stage\": \"Semantic Analysis\", \"Result\": type_check_result}])\ntools.display_dataframe_to_user(\n    name=\"Type Checking Result for AegisLang\",\n    dataframe=df_result\n)\n\n# 4) Code Generation\ncode_gen = CodeGenerator(ast)\nllvm_ir = code_gen.generate()\ndf_llvm = pd.DataFrame([{\"LLVM IR\": llvm_ir}])\ntools.display_dataframe_to_user(\n    name=\"LLVM IR for AegisLang\",\n    dataframe=df_llvm\n)\n\n# 5) JIT Compilation & Execution\njit_compiler = JITCompiler(llvm_ir)\nexecution_result = jit_compiler.compile_and_execute()\ndf_execution = pd.DataFrame([{\"Stage\": \"Compilation & Execution\", \"Result\": execution_result}])\ntools.display_dataframe_to_user(\n    name=\"AegisLang Compilation & Execution Result\",\n    dataframe=df_execution\n)\n\nprint(\"Demo completed successfully!\")\n", "size": 2030, "lastModified": 1741345565.6433961, "moduleContext": "examples", "structure": {"modules": ["UserSystem"], "structs": ["User"], "functions": ["create_user"], "imports": ["pandas as pd", "ace_tools as tools  # If you truly need to display DataFrames in your environment", "("], "types": [], "sections": [], "function_signatures": ["create_user(name: string, age: int) -> User"]}, "stats": {"line_count": 77, "function_count": 1, "class_count": 0, "complexity_estimate": 6}, "contentHash": "d059f5512150e4879ac1eb6fb7704971"}
{"filePath": "examples/user_system.ae", "language": "Aegis", "content": "module UserSystem:\n    struct User:\n        name: string\n        age: int\n        is_active: bool = true\n    \n    enum UserRole:\n        Guest\n        Regular\n        Admin(string)  # Admin with permission level\n    \n    fn get_user(name: string) -> User:\n        let default_age: int = 30\n        return User(name, default_age)\n    \n    fn is_admin(role: UserRole) -> bool:\n        if role == UserRole.Admin:\n            return true\n        else:\n            return false ", "size": 473, "lastModified": 1741347463.5458267, "moduleContext": "examples", "structure": {"modules": ["UserSystem"], "structs": ["User"], "functions": ["get_user", "is_admin"], "imports": [], "types": [], "sections": [], "function_signatures": ["get_user(name: string) -> User", "is_admin(role: UserRole) -> bool"]}, "stats": {"line_count": 20, "function_count": 2, "class_count": 0, "complexity_estimate": 6}, "contentHash": "91d5648acf63264b08c3884c9b5674f7"}
{"filePath": "examples/minimal.ae", "language": "Aegis", "content": "module Minimal:\n    struct Empty:\n        x: int ", "size": 49, "lastModified": 1741351960.0435593, "moduleContext": "examples", "structure": {"modules": ["Minimal"], "structs": ["Empty"], "functions": [], "imports": [], "types": [], "sections": [], "function_signatures": []}, "stats": {"line_count": 3, "function_count": 0, "class_count": 0, "complexity_estimate": 1}, "contentHash": "fa68845349c9c283ba9e4558c6d53845"}
{"filePath": "examples/demo_pkg_manager.ae", "language": "Aegis", "content": "import pandas as pd\nimport ace_tools as tools\n# from pkg_manager.package_manager import AegisPackageManager\n\ndef main():\n    pkg_manager = AegisPackageManager()\n\n    # 1) Create a project\n    project_creation_result = pkg_manager.create_project(\"MyAegisProject\")\n\n    # 2) Install packages\n    pkg_install_result1 = pkg_manager.install_package(\"MyAegisProject\", \"http_client\", \"1.0.0\")\n    pkg_install_result2 = pkg_manager.install_package(\"MyAegisProject\", \"json_parser\", \"2.1.3\")\n\n    # 3) List dependencies\n    installed_dependencies = pkg_manager.list_dependencies(\"MyAegisProject\")\n\n    df_pkg_manager = pd.DataFrame([\n        {\"Action\": \"Create Project\", \"Result\": project_creation_result},\n        {\"Action\": \"Install Package\", \"Result\": pkg_install_result1},\n        {\"Action\": \"Install Package\", \"Result\": pkg_install_result2},\n        {\"Action\": \"List Dependencies\", \"Result\": str(installed_dependencies)}\n    ])\n    tools.display_dataframe_to_user(name=\"AegisLang Package Manager Results\", dataframe=df_pkg_manager)\n\n    print(\"Package manager demo complete!\")\n\nif __name__ == \"__main__\":\n    main()\n", "size": 1111, "lastModified": 1741345565.6435802, "moduleContext": "examples", "structure": {"modules": [], "structs": [], "functions": [], "imports": ["pandas as pd", "ace_tools as tools", "AegisPackageManager"], "types": [], "sections": [], "function_signatures": []}, "stats": {"line_count": 30, "function_count": 0, "class_count": 0, "complexity_estimate": 2}, "contentHash": "54aab84074a4169f58c23e38a0545650"}
{"filePath": "examples/name_age.ae", "language": "Aegis", "content": "module UserSystem:\n    struct User:\n        name: string\n        age: int\n\n    fn create_user(name: string, age: int) -> User:\n        return User(name, age)", "size": 157, "lastModified": 1741345565.6447387, "moduleContext": "examples", "structure": {"modules": ["UserSystem"], "structs": ["User"], "functions": ["create_user"], "imports": [], "types": [], "sections": [], "function_signatures": ["create_user(name: string, age: int) -> User"]}, "stats": {"line_count": 7, "function_count": 1, "class_count": 0, "complexity_estimate": 2}, "contentHash": "cb29c1ddd4ee8d42c6a7a6e83181af07"}
{"filePath": "examples/basic.ae", "language": "Aegis", "content": "module Basic:\n    struct Point:\n        x: int\n        y: int\n    \n    fn test() -> int:\n        let a: int = 5\n        let b: int = 10\n        return a + b ", "size": 157, "lastModified": 1741351947.4660661, "moduleContext": "examples", "structure": {"modules": ["Basic"], "structs": ["Point"], "functions": ["test"], "imports": [], "types": [], "sections": [], "function_signatures": ["test() -> int"]}, "stats": {"line_count": 9, "function_count": 1, "class_count": 0, "complexity_estimate": 2}, "contentHash": "3c053913f943a64e596eeb4c21694acd"}
{"filePath": "examples/demo_wasm.ae", "language": "Aegis", "content": "import pandas as pd\nimport ace_tools as tools\n\n# from wasm.wasm_compiler import WebAssemblyCompiler, WebAssemblyIRGenerator\n# from benchmarks.benchmark import AegisLangBenchmark, AOTCompiler\n\ndef main():\n    # We'll assume you have some example LLVM IR or you generate it earlier in code:\n    llvm_ir = \"; your earlier generated IR here...\"\n\n    # 1) WebAssembly Compilation\n    wasm_compiler = WebAssemblyCompiler(llvm_ir)\n    wasm_result = wasm_compiler.compile_to_wasm()\n\n    df_wasm = pd.DataFrame([{\"Stage\": \"WebAssembly Compilation\", \"Result\": wasm_result}])\n    tools.display_dataframe_to_user(name=\"AegisLang WebAssembly Compilation Results\", dataframe=df_wasm)\n\n    # 2) AOT Compilation \n    aot_compiler = AOTCompiler(llvm_ir)\n    native_compile_result = aot_compiler.compile_to_native()\n\n    df_aot = pd.DataFrame([{\"Stage\": \"Native Binary Compilation\", \"Result\": native_compile_result}])\n    tools.display_dataframe_to_user(name=\"AegisLang Native Compilation Results\", dataframe=df_aot)\n\n    # 3) Benchmarks\n    benchmark = AegisLangBenchmark(llvm_ir)\n    benchmark_results = benchmark.run_benchmarks()\n\n    df_benchmarks = pd.DataFrame(benchmark_results)\n    tools.display_dataframe_to_user(name=\"AegisLang Performance Benchmark Results\", dataframe=df_benchmarks)\n\n    print(\"WASM, AOT, and Benchmark demo complete!\")\n\nif __name__ == \"__main__\":\n    main()\n", "size": 1370, "lastModified": 1741345565.6442528, "moduleContext": "examples", "structure": {"modules": [], "structs": [], "functions": [], "imports": ["pandas as pd", "ace_tools as tools", "WebAssemblyCompiler, WebAssemblyIRGenerator", "AegisLangBenchmark, AOTCompiler"], "types": [], "sections": [], "function_signatures": []}, "stats": {"line_count": 36, "function_count": 0, "class_count": 0, "complexity_estimate": 2}, "contentHash": "59f6f066d1bd1f79ea4e57bf13a3f612"}
{"filePath": "examples/demo_ai.ae", "language": "Aegis", "content": "\"\"\"\nDemonstration of AI-driven code generation, validation, \nSaaS module creation, and documentation generation.\n\"\"\"\n\nimport pandas as pd\nimport ace_tools as tools\n\n# Import your AI classes from whichever module you defined them in:\n# from compiler.aegis_ai_generator import (\n#     AegisAI_CodeGenerator, \n#     AegisAI_CodeValidator,\n#     AegisAI_SaaSCodeGeneratorFixed, \n#     AegisLangDocumentation,\n#     AegisAI_EnterpriseCodeGenerator,\n#     AegisAI_CodeOptimizer\n# )\n\ndef main():\n    # 1) Basic AI Code Generation\n    ai_generator = AegisAI_CodeGenerator()\n    generated_code = ai_generator.generate_module()\n    df_generated_code = pd.DataFrame([{\"Generated AegisLang Code\": generated_code}])\n    tools.display_dataframe_to_user(name=\"AI-Generated AegisLang Code\", dataframe=df_generated_code)\n\n    # 2) Validation\n    validator = AegisAI_CodeValidator(generated_code)\n    validation_result = validator.run_validation()\n    df_validation = pd.DataFrame([{\"Stage\": \"AI Code Validation\", \"Result\": validation_result}])\n    tools.display_dataframe_to_user(name=\"AegisLang AI Code Validation Results\", dataframe=df_validation)\n\n    # 3) SaaS CRUD Generation\n    saas_generator_fixed = AegisAI_SaaSCodeGeneratorFixed()\n    generated_saas_code_fixed = saas_generator_fixed.generate_crud_module(\"Customer\")\n    df_saas_code_fixed = pd.DataFrame([{\"Generated SaaS Module Code\": generated_saas_code_fixed}])\n    tools.display_dataframe_to_user(name=\"AI-Generated SaaS Module in AegisLang (Fixed)\", dataframe=df_saas_code_fixed)\n\n    # 4) Documentation\n    doc_generator = AegisLangDocumentation()\n    aegislang_docs = doc_generator.generate_documentation()\n    df_docs = pd.DataFrame([{\"AegisLang Documentation\": aegislang_docs}])\n    tools.display_dataframe_to_user(name=\"AegisLang Documentation\", dataframe=df_docs)\n\n    # 5) Enterprise SaaS Project\n    enterprise_generator = AegisAI_EnterpriseCodeGenerator()\n    generated_enterprise_code = enterprise_generator.generate_full_saas_project(\"ECommercePlatform\")\n    df_enterprise_code = pd.DataFrame([{\"Generated Enterprise SaaS Code\": generated_enterprise_code}])\n    tools.display_dataframe_to_user(name=\"AI-Generated Enterprise SaaS Project in AegisLang\", dataframe=df_enterprise_code)\n\n    # 6) Optimize AI Code\n    ai_optimizer = AegisAI_CodeOptimizer(generated_enterprise_code)\n    optimized_ai_code = ai_optimizer.run_optimizations()\n    df_optimized_ai_code = pd.DataFrame([{\"Optimized AI-Generated Code\": optimized_ai_code}])\n    tools.display_dataframe_to_user(name=\"Optimized AI-Generated AegisLang Code\", dataframe=df_optimized_ai_code)\n\n    print(\"AI code generation demo complete!\")\n\nif __name__ == \"__main__\":\n    main()\n", "size": 2689, "lastModified": 1741345565.6431723, "moduleContext": "examples", "structure": {"modules": [], "structs": [], "functions": [], "imports": ["pandas as pd", "ace_tools as tools", "("], "types": [], "sections": [], "function_signatures": []}, "stats": {"line_count": 60, "function_count": 0, "class_count": 0, "complexity_estimate": 2}, "contentHash": "83a05b69a140a3a2c1d42b5d04678b75"}
{"filePath": "examples/simple.ae", "language": "Aegis", "content": "module Test:\n    struct Point:\n        x: int\n        y: int\n    \n    fn create_point(x: int, y: int) -> Point:\n        return Point(x, y) ", "size": 139, "lastModified": 1741351083.527113, "moduleContext": "examples", "structure": {"modules": ["Test"], "structs": ["Point"], "functions": ["create_point"], "imports": [], "types": [], "sections": [], "function_signatures": ["create_point(x: int, y: int) -> Point"]}, "stats": {"line_count": 7, "function_count": 1, "class_count": 0, "complexity_estimate": 2}, "contentHash": "84dba9d24fd0b52cf176bd9bce487fee"}
{"filePath": "benchmarks/benchmark.py", "language": "Python", "content": "# Performance Benchmarking for AegisLang\n\nimport time\nfrom llvmlite import binding\nimport pandas as pd\nimport ace_tools as tools\n\n# Enabling Native Binary Compilation (LLVM AOT Compiler)\n\n\nclass AOTCompiler:\n    \"\"\"Compiles AegisLang LLVM IR into a native binary.\"\"\"\n\n    def __init__(self, llvm_ir, output_filename=\"aegis_binary\"):\n        self.llvm_ir = llvm_ir\n        self.output_filename = output_filename\n\n    def compile_to_native(self):\n        \"\"\"Compiles LLVM IR to a native binary.\"\"\"\n        # Create LLVM module from IR\n        llvm_module = binding.parse_assembly(self.llvm_ir)\n        llvm_module.verify()\n\n        # Set target triple to the native machine\n        target = binding.Target.from_default_triple()\n        target_machine = target.create_target_machine()\n\n        # Generate native object code\n        object_code = target_machine.emit_object(llvm_module)\n\n        # Save object file\n        obj_filename = f\"{self.output_filename}.o\"\n        with open(obj_filename, \"wb\") as obj_file:\n            obj_file.write(object_code)\n\n        # Normally, the object file would be linked using `clang` or `lld`:\n        # `clang aegis_binary.o -o aegis_binary`\n\n        return f\"Native compilation successful. Object file saved as '{obj_filename}'.\"\n\n\nclass AegisLangBenchmark:\n    \"\"\"Tests the execution speed of AI-generated AegisLang code compiled to native binaries.\"\"\"\n\n    def __init__(self, llvm_ir):\n        self.llvm_ir = llvm_ir\n\n    def benchmark_native_compilation(self):\n        \"\"\"Measures the time taken to compile LLVM IR to a native binary.\"\"\"\n        start_time = time.time()\n\n        # Compile to native object code\n        aot_compiler = AOTCompiler(self.llvm_ir, output_filename=\"benchmark_test\")\n        compile_result = aot_compiler.compile_to_native()\n\n        end_time = time.time()\n        compile_time = end_time - start_time\n\n        return {\n            \"Stage\": \"Native Compilation\",\n            \"Time (s)\": compile_time,\n            \"Result\": compile_result,\n        }\n\n    def benchmark_execution_time(self):\n        \"\"\"Measures execution speed of a compiled AegisLang binary.\"\"\"\n        start_time = time.time()\n\n        # Simulate execution (since actual execution needs full system compilation)\n        time.sleep(0.5)  # Placeholder for real binary execution\n\n        end_time = time.time()\n        execution_time = end_time - start_time\n\n        return {\n            \"Stage\": \"Execution\",\n            \"Time (s)\": execution_time,\n            \"Result\": \"Simulated Execution Completed\",\n        }\n\n    def run_benchmarks(self):\n        \"\"\"Runs all benchmark tests.\"\"\"\n        results = [self.benchmark_native_compilation(), self.benchmark_execution_time()]\n        return results\n\n\nif __name__ == \"__main__\":\n    # Suppose we have wasm_llvm_ir from the CodeGenerator or similar\n    wasm_llvm_ir = \"; Example LLVM IR for WASM...\"\n    benchmark = AegisLangBenchmark(wasm_llvm_ir)\n    results = benchmark.run_benchmarks()\n\n    df_benchmarks = pd.DataFrame(results)\n    tools.display_dataframe_to_user(\n        name=\"AegisLang Performance Benchmark Results\", dataframe=df_benchmarks\n    )\n", "size": 3137, "lastModified": 1741345565.6384978, "moduleContext": "benchmarks", "structure": {"classes": ["AegisLangBenchmark", "AOTCompiler"], "functions": ["benchmark_execution_time", "__init__", "benchmark_native_compilation", "run_benchmarks", "compile_to_native"], "imports": ["IR", "llvmlite", "time", "the", "pandas", "binding", "ace_tools"]}, "stats": {"line_count": 97, "function_count": 5, "class_count": 2, "complexity_estimate": 9}, "contentHash": "26f9c7add7da31b706312fc51686a425"}
{"filePath": "src/test_parser.py", "language": "Python", "content": "#!/usr/bin/env python3\n\"\"\"\nTest script for the Aegis parser.\nThis script loads and parses an Aegis file using the ANTLR-based parser.\n\"\"\"\n\nimport os\nimport sys\nimport json\nfrom pathlib import Path\n\n# Add the src directory to the path\nsys.path.insert(0, str(Path(__file__).parent))\n\nfrom parser.aegis_parser import AegisParser\n\n\ndef main():\n    \"\"\"Main function to test the parser.\"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: python test_parser.py <aegis_file>\")\n        print(\"Example: python test_parser.py examples/user_system.ae\")\n        sys.exit(1)\n    \n    file_path = sys.argv[1]\n    if not os.path.exists(file_path):\n        print(f\"Error: File '{file_path}' not found.\")\n        sys.exit(1)\n    \n    parser = AegisParser()\n    try:\n        print(f\"Parsing file: {file_path}\")\n        ast = parser.parse_file(file_path)\n        \n        # Print the AST as formatted JSON\n        print(\"\\nParsed AST:\")\n        print(json.dumps(ast, indent=2))\n        \n        print(\"\\nParsing completed successfully!\")\n    except Exception as e:\n        print(f\"\\nError parsing file: {e}\")\n        import traceback\n        traceback.print_exc()\n        sys.exit(1)\n\n\nif __name__ == \"__main__\":\n    main() ", "size": 1204, "lastModified": 1741347541.3946419, "moduleContext": "src", "structure": {"classes": [], "functions": ["main"], "imports": ["sys", "traceback", "Path", "json", "os", "AegisParser", "parser", "pathlib"]}, "stats": {"line_count": 48, "function_count": 1, "class_count": 0, "complexity_estimate": 7}, "contentHash": "4e265f25644e99efcbc8e821e1622148"}
{"filePath": "src/test_preprocessor.py", "language": "Python", "content": "#!/usr/bin/env python3\n\"\"\"\nTest script for the indentation preprocessor.\n\"\"\"\n\nimport sys\nimport os\nfrom pathlib import Path\n\n# Add the src directory to the path\nscript_dir = os.path.dirname(os.path.abspath(__file__))\nif script_dir not in sys.path:\n    sys.path.insert(0, script_dir)\n\nfrom lexer.indentation_lexer import AegisIndentationLexer\n\n\ndef main():\n    \"\"\"Test the indentation preprocessor.\"\"\"\n    if len(sys.argv) < 2:\n        print(\"Usage: python test_preprocessor.py <aegis_file>\")\n        sys.exit(1)\n    \n    # Read the input file\n    with open(sys.argv[1], 'r') as f:\n        input_text = f.read()\n    \n    # Preprocess the input\n    preprocessor = AegisIndentationLexer(None)\n    output = preprocessor.process_indentation(input_text)\n    \n    # Print the preprocessed output\n    print(\"Preprocessed output:\")\n    print(\"-\" * 50)\n    print(output)\n    print(\"-\" * 50)\n    \n    # Print any errors\n    if preprocessor.indent_errors:\n        print(\"\\nIndentation errors:\")\n        for error in preprocessor.indent_errors:\n            print(f\"{error['message']}\\n{error['suggestion']}\")\n\n\nif __name__ == \"__main__\":\n    main() ", "size": 1136, "lastModified": 1741350598.760847, "moduleContext": "src", "structure": {"classes": [], "functions": ["main"], "imports": ["sys", "lexer", "AegisIndentationLexer", "Path", "os", "pathlib"]}, "stats": {"line_count": 46, "function_count": 1, "class_count": 0, "complexity_estimate": 7}, "contentHash": "a649867b9ec4f87c726f5ca74b865a57"}
{"filePath": "src/ai_generator/ai_generator.py", "language": "Python", "content": "\"\"\"\nAegisLang AI Code Generator\nThis file implements AI-driven code generation for structured AegisLang code,\nincluding SaaS module generation and enterprise project scaffolding.\n\"\"\"\n\nimport random\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nclass AegisAI_CodeGenerator:\n    \"\"\"Automatically generates valid AegisLang code based on predefined templates.\"\"\"\n\n    def __init__(self):\n        self.templates = {\n            \"struct\": \"struct {name}:\\n    {fields}\\n\",\n            \"function\": \"fn {name}({params}) -> {return_type}:\\n    {body}\\n\",\n            \"module\": \"module {name}:\\n    {content}\\n\",\n        }\n        self.sample_types = [\"int\", \"string\", \"bool\"]\n        self.sample_functions = [\"get_user\", \"calculate_sum\", \"fetch_data\"]\n        self.sample_structs = [\"User\", \"Product\", \"Order\"]\n\n    def generate_struct(self, name=None):\n        \"\"\"Generates a random struct definition.\"\"\"\n        name = name or random.choice(self.sample_structs)\n        fields = \"\\n    \".join(\n            [\n                f\"{random.choice(['id', 'name', 'value'])}: {random.choice(self.sample_types)}\"\n                for _ in range(2)\n            ]\n        )\n        return self.templates[\"struct\"].format(name=name, fields=fields)\n\n    def generate_function(self, name=None):\n        \"\"\"Generates a random function definition.\"\"\"\n        name = name or random.choice(self.sample_functions)\n        params = f\"{random.choice(['x', 'y'])}: {random.choice(self.sample_types)}\"\n        return_type = random.choice(self.sample_types)\n        body = \"    return x + 1\" if return_type == \"int\" else '    return \"sample\"'\n        return self.templates[\"function\"].format(\n            name=name, params=params, return_type=return_type, body=body\n        )\n\n    def generate_module(self, name=\"SampleModule\"):\n        \"\"\"Generates a complete module with struct and function.\"\"\"\n        struct_def = self.generate_struct()\n        function_def = self.generate_function()\n        content = f\"{struct_def}\\n{function_def}\"\n        return self.templates[\"module\"].format(name=name, content=content)\n\n\n# Implementing AI Code Validation for AegisLang\nclass AegisAI_CodeValidator:\n    \"\"\"Validates AI-generated AegisLang code to ensure correctness.\"\"\"\n\n    def __init__(self, generated_code):\n        self.code = generated_code\n        self.errors = []\n\n    def validate_syntax(self):\n        \"\"\"Checks for basic syntax errors.\"\"\"\n        lines = self.code.split(\"\\n\")\n        indent_level = 0\n\n        for line in lines:\n            stripped = line.strip()\n\n            if not stripped:\n                continue\n\n            # Check for missing colons in struct and function definitions\n            if (\n                stripped.startswith(\"struct\")\n                or stripped.startswith(\"fn\")\n                or stripped.startswith(\"module\")\n            ):\n                if \":\" not in stripped:\n                    self.errors.append(\n                        f\"Syntax Error: Missing ':' in definition: {stripped}\"\n                    )\n\n            # Check indentation consistency\n            current_indent = len(line) - len(line.lstrip())\n            if current_indent % 4 != 0:\n                self.errors.append(\n                    f\"Syntax Error: Inconsistent indentation on line: {line}\"\n                )\n\n            # Ensure function return statements are correct\n            if stripped.startswith(\"return \"):\n                if \"(\" in stripped or \")\" in stripped:\n                    self.errors.append(\n                        f\"Syntax Error: Invalid function return format: {stripped}\"\n                    )\n\n    def validate_types(self):\n        \"\"\"Checks if types are properly defined.\"\"\"\n        allowed_types = {\"int\", \"string\", \"bool\", \"float\"}\n        lines = self.code.split(\"\\n\")\n\n        for line in lines:\n            stripped = line.strip()\n            if \":\" in stripped and (\"struct\" not in stripped and \"fn\" not in stripped):\n                parts = stripped.split(\":\")\n                if len(parts) > 1:\n                    declared_type = parts[1].strip()\n                    if declared_type not in allowed_types:\n                        self.errors.append(\n                            f\"Type Error: Undefined type '{declared_type}' in line: {stripped}\"\n                        )\n\n    def run_validation(self):\n        \"\"\"Runs all validation checks.\"\"\"\n        self.validate_syntax()\n        self.validate_types()\n\n        if not self.errors:\n            return \"Code Validation Passed \u2705\"\n        return \"\\n\".join(self.errors)\n\n\n# Enhancing AI Code Generation for Complex SaaS Development\nclass AegisAI_SaaSCodeGeneratorFixed(AegisAI_CodeGenerator):\n    \"\"\"Generates AI-optimized AegisLang code for SaaS applications with proper string formatting.\"\"\"\n\n    def generate_crud_module(self, entity_name=\"User\"):\n        \"\"\"Generates a complete CRUD module for a given entity.\"\"\"\n        struct_def = self.generate_struct(entity_name)\n\n        functions = [\n            self.templates[\"function\"].format(\n                name=f\"create_{entity_name.lower()}\",\n                params=f\"data: {entity_name}\",\n                return_type=\"bool\",\n                body=\"    return true\",\n            ),\n            self.templates[\"function\"].format(\n                name=f\"get_{entity_name.lower()}\",\n                params=\"id: int\",\n                return_type=entity_name,\n                body=f'    return {entity_name}(id=1, name=\"Sample\")',\n            ),\n            self.templates[\"function\"].format(\n                name=f\"update_{entity_name.lower()}\",\n                params=f\"id: int, data: {entity_name}\",\n                return_type=\"bool\",\n                body=\"    return true\",\n            ),\n            self.templates[\"function\"].format(\n                name=f\"delete_{entity_name.lower()}\",\n                params=\"id: int\",\n                return_type=\"bool\",\n                body=\"    return true\",\n            ),\n        ]\n\n        module_content = f\"{struct_def}\\n\" + \"\\n\".join(functions)\n        return self.templates[\"module\"].format(\n            name=f\"{entity_name}Module\", content=module_content\n        )\n\n\n# Finalizing AegisLang Features & Documentation\n\n\nclass AegisLangDocumentation:\n    \"\"\"Generates structured documentation for AegisLang, covering syntax, features, and usage.\"\"\"\n\n    def __init__(self):\n        self.documentation = {\n            \"Introduction\": \"AegisLang is an AI-optimized programming language designed for deterministic, fast, and safe code generation.\",\n            \"Syntax Overview\": {\n                \"Module\": \"module ModuleName:\\n    # Define structs and functions inside modules\",\n                \"Struct\": \"struct StructName:\\n    field1: type\\n    field2: type\",\n                \"Function\": \"fn functionName(param1: type, param2: type) -> returnType:\\n    # Function logic\",\n                \"Control Flow\": \"if condition:\\n    # Code block\\nelif condition:\\n    # Alternative block\\nelse:\\n    # Default block\",\n                \"Loops\": \"for i in 0..10:\\n    # Loop logic\\n\\nwhile condition:\\n    # While loop logic\",\n            },\n            \"Standard Library\": {\n                \"Arithmetic\": [\n                    \"add(a: int, b: int) -> int\",\n                    \"subtract(a: int, b: int) -> int\",\n                ],\n                \"String Operations\": [\n                    \"length(s: string) -> int\",\n                    \"concat(s1: string, s2: string) -> string\",\n                ],\n                \"File I/O\": [\n                    \"read_file(filename: string) -> string\",\n                    \"write_file(filename: string, content: string) -> bool\",\n                ],\n                \"Networking\": [\n                    \"http_get(url: string) -> string\",\n                    \"http_post(url: string, data: string) -> string\",\n                ],\n                \"Date/Time\": [\n                    \"current_timestamp() -> int\",\n                    \"format_date(timestamp: int, format: string) -> string\",\n                ],\n            },\n            \"Compilation Targets\": [\n                \"LLVM IR (.ll) - Optimized for AI-driven compilation\",\n                \"WebAssembly (.wasm) - Portable execution\",\n                \"Native Binary (.o, .exe) - High-performance local execution\",\n            ],\n            \"AI Code Generation\": \"AegisLang features AI-driven code generation for SaaS modules, ensuring consistent syntax and optimized logic.\",\n            \"Package Management\": \"Use the AegisLang package manager to create projects, install packages, and manage dependencies.\",\n            \"Future Roadmap\": \"Enhancements for AI-driven optimizations, cloud-native deployments, and broader ecosystem integration.\",\n        }\n\n    def generate_documentation(self):\n        \"\"\"Formats the documentation into a structured output.\"\"\"\n        formatted_doc = \"\"\n        for section, content in self.documentation.items():\n            formatted_doc += f\"## {section}\\n\\n\"\n            if isinstance(content, dict):\n                for sub_section, sub_content in content.items():\n                    formatted_doc += f\"### {sub_section}\\n\"\n                    if isinstance(sub_content, list):\n                        for item in sub_content:\n                            formatted_doc += f\"- {item}\\n\"\n                    else:\n                        formatted_doc += f\"{sub_content}\\n\\n\"\n            elif isinstance(content, list):\n                for item in content:\n                    formatted_doc += f\"- {item}\\n\"\n            else:\n                formatted_doc += f\"{content}\\n\\n\"\n        return formatted_doc\n\n\n# Optimizing AI Code Generation for Large-Scale SaaS Projects\nclass AegisAI_EnterpriseCodeGenerator(AegisAI_SaaSCodeGenerator):\n    \"\"\"Generates AI-optimized AegisLang code for large-scale enterprise SaaS applications.\"\"\"\n\n    def generate_full_saas_project(self, project_name=\"EnterpriseSaaS\"):\n        \"\"\"Generates a complete multi-module SaaS project structure.\"\"\"\n        entities = [\"User\", \"Order\", \"Product\", \"Invoice\"]\n        modules = [self.generate_crud_module(entity) for entity in entities]\n        project_structure = f\"module {project_name}:\\n\\n\" + \"\\n\\n\".join(modules)\n        return project_structure\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    generator = AegisAI_EnterpriseCodeGenerator()\n    enterprise_code = generator.generate_full_saas_project(\"ECommercePlatform\")\n    print(enterprise_code)\n", "size": 10440, "lastModified": 1741346189.3271677, "moduleContext": "src/ai_generator", "structure": {"classes": ["AegisAI_EnterpriseCodeGenerator", "AegisLangDocumentation", "AegisAI_SaaSCodeGeneratorFixed", "AegisAI_CodeValidator", "AegisAI_CodeGenerator"], "functions": ["generate_function", "run_validation", "__init__", "validate_syntax", "generate_crud_module", "generate_full_saas_project", "generate_documentation", "generate_struct", "generate_module", "validate_types"], "imports": ["random", "get_logger", "utils"]}, "stats": {"line_count": 251, "function_count": 10, "class_count": 5, "complexity_estimate": 65}, "contentHash": "cec7a270b02ebe01db6532d76ed0e17c"}
{"filePath": "src/ai_generator/ai_optimizer.py", "language": "Python", "content": "from utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\nclass AegisAI_CodeOptimizer:\n    \"\"\"Refines AI-generated AegisLang code for maximum efficiency and scalability.\"\"\"\n\n    def __init__(self, generated_code):\n        self.code = generated_code\n\n    def optimize_code_structure(self):\n        \"\"\"Refactors and optimizes code layout for readability and execution speed.\"\"\"\n        optimized_code = self.code.replace(\"\\n\\n\", \"\\n\")  # Remove excessive newlines\n        return optimized_code\n\n    def remove_redundant_code(self):\n        \"\"\"Removes unnecessary code or duplicate declarations.\"\"\"\n        lines = self.code.split(\"\\n\")\n        unique_lines = []\n        seen = set()\n\n        for line in lines:\n            stripped = line.strip()\n            if stripped and stripped not in seen:\n                unique_lines.append(line)\n                seen.add(stripped)\n\n        return \"\\n\".join(unique_lines)\n\n    def enforce_best_practices(self):\n        \"\"\"Ensures AI-generated code follows best practices.\"\"\"\n        best_practices_code = self.code.replace(\n            \"return true\", \"return Ok(true)\"\n        )  # Use proper return handling\n        return best_practices_code\n\n    def run_optimizations(self):\n        \"\"\"Applies all optimization steps.\"\"\"\n        optimized_code = self.optimize_code_structure()\n        optimized_code = self.remove_redundant_code()\n        optimized_code = self.enforce_best_practices()\n        return optimized_code\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    # Suppose we have some AI-generated code\n    generated_enterprise_code = \"\"\"\nmodule ECommercePlatform:\n\n    module UserModule:\n        struct User:\n            id: int\n            name: string\n\n        fn create_user(data: User) -> bool:\n            return true\n    \"\"\"\n\n    ai_optimizer = AegisAI_CodeOptimizer(generated_enterprise_code)\n    optimized_code = ai_optimizer.run_optimizations()\n    print(\"Optimized code:\\n\", optimized_code)\n", "size": 1959, "lastModified": 1741346199.2003522, "moduleContext": "src/ai_generator", "structure": {"classes": ["AegisAI_CodeOptimizer"], "functions": ["enforce_best_practices", "remove_redundant_code", "__init__", "run_optimizations", "optimize_code_structure"], "imports": ["utils", "get_logger"]}, "stats": {"line_count": 63, "function_count": 5, "class_count": 1, "complexity_estimate": 14}, "contentHash": "8fc8dc73820e175f11f3ab1df9672f49"}
{"filePath": "src/security/security_audit.py", "language": "Python", "content": "# Final Testing & Security Audits for AegisLang\n\nimport hashlib\n\n\nclass AegisLangSecurityAudit:\n    \"\"\"Performs security checks on AegisLang compiler, standard library, and AI-generated code.\"\"\"\n\n    def __init__(self, code_samples):\n        self.code_samples = code_samples\n\n    def detect_insecure_patterns(self):\n        \"\"\"Scans for common security vulnerabilities in AI-generated code.\"\"\"\n        insecure_patterns = [\"eval(\", \"exec(\", \"system(\", \"subprocess.call(\"]\n        found_issues = []\n\n        for sample in self.code_samples:\n            for pattern in insecure_patterns:\n                if pattern in sample:\n                    found_issues.append(\n                        f\"Potential security risk: Found '{pattern}' in code.\"\n                    )\n\n        return (\n            found_issues if found_issues else [\"No security vulnerabilities detected.\"]\n        )\n\n    def integrity_check(self, code):\n        \"\"\"Generates a hash of the AI-generated code for integrity validation.\"\"\"\n        return hashlib.sha256(code.encode()).hexdigest()\n\n    def run_audit(self):\n        \"\"\"Runs all security and integrity tests.\"\"\"\n        audit_results = {\n            \"Security Scan\": self.detect_insecure_patterns(),\n            \"Code Integrity Hash\": [\n                self.integrity_check(sample) for sample in self.code_samples\n            ],\n        }\n        return audit_results\n\n\nif __name__ == \"__main__\":\n    # Example usage\n    generated_enterprise_code = \"module ECommerce...\"\n    optimized_ai_code = \"module ECommerce optimized...\"\n    audit = AegisLangSecurityAudit([generated_enterprise_code, optimized_ai_code])\n    results = audit.run_audit()\n    print(\"Security Scan:\", results[\"Security Scan\"])\n    print(\"Integrity Hashes:\", results[\"Code Integrity Hash\"])\n", "size": 1785, "lastModified": 1741345565.6462827, "moduleContext": "src/security", "structure": {"classes": ["AegisLangSecurityAudit"], "functions": ["detect_insecure_patterns", "integrity_check", "__init__", "run_audit"], "imports": ["hashlib"]}, "stats": {"line_count": 51, "function_count": 4, "class_count": 1, "complexity_estimate": 14}, "contentHash": "4f9ff7b2e8d46b724e37ec4d164ff5fa"}
{"filePath": "src/lexer/indentation_lexer.py", "language": "Python", "content": "from antlr4 import Token\nfrom typing import List, Dict, Any, Optional\n\n\nclass AegisIndentationLexer:\n    \"\"\"\n    A lexer that handles Python-style indentation, producing INDENT and DEDENT tokens\n    for the ANTLR4 parser. This is designed specifically for AI code generation\n    with clear error messages and position tracking.\n    \"\"\"\n    \n    # Token types from the grammar\n    INDENT_TYPE = 76  # INDENT token type from AegisLangLexer\n    DEDENT_TYPE = 77  # DEDENT token type from AegisLangLexer\n    COLON_TYPE = 45   # COLON token type from AegisLangLexer\n\n    def __init__(self, lexer):\n        \"\"\"\n        Initialize the indentation lexer with an underlying ANTLR4 lexer.\n        \n        Args:\n            lexer: The underlying ANTLR4 lexer that produces tokens\n        \"\"\"\n        self.lexer = lexer\n        self.indents = [0]          # Indentation stack, starting with 0 (no indent)\n        self.indent_errors = []     # Track indentation errors\n    \n    def process_indentation(self, input_text: str) -> str:\n        \"\"\"\n        Process the input text to add explicit INDENT/DEDENT tokens.\n        This is a simplified approach that works with the grammar.\n        \n        Args:\n            input_text: The source code to preprocess\n            \n        Returns:\n            The processed source with explicit INDENT and DEDENT tokens\n        \"\"\"\n        lines = input_text.split('\\n')\n        result = []\n        indentation_stack = [0]  # Start with 0 indentation\n        pending_dedents = 0      # Track pending dedents for empty lines\n        \n        for i, line in enumerate(lines):\n            # Handle empty lines and comments - preserve them but don't change indentation\n            stripped = line.strip()\n            if not stripped or stripped.startswith('#'):\n                result.append(line)\n                continue\n            \n            # Calculate the indentation level (number of spaces)\n            indent_level = len(line) - len(line.lstrip())\n            content = line.lstrip()\n            \n            # Check for indentation change\n            if indent_level > indentation_stack[-1]:\n                # Indentation increased - add INDENT token\n                result.append(\" \" * indent_level + f\"INDENT {content}\")\n                indentation_stack.append(indent_level)\n                pending_dedents = 0\n            elif indent_level < indentation_stack[-1]:\n                # Indentation decreased - add DEDENT tokens\n                dedent_count = 0\n                while indentation_stack and indent_level < indentation_stack[-1]:\n                    indentation_stack.pop()\n                    dedent_count += 1\n                \n                # Check for invalid indentation\n                if indent_level not in indentation_stack:\n                    # Invalid indentation - add error message\n                    error = self._create_indentation_error(indent_level, i+1, 0)\n                    self.indent_errors.append(error)\n                    # Try to recover by adding the closest valid indentation\n                    closest_indent = min(indentation_stack, key=lambda x: abs(x - indent_level))\n                    indentation_stack.append(closest_indent)\n                \n                # Add the right number of DEDENT tokens before the content\n                if dedent_count > 0:\n                    dedents = \" \".join([\"DEDENT\"] * dedent_count)\n                    result.append(\" \" * indent_level + f\"{dedents} {content}\")\n                    pending_dedents = 0\n                else:\n                    result.append(line)\n            else:\n                # No indentation change\n                if pending_dedents > 0:\n                    # Apply any pending dedents\n                    dedents = \" \".join([\"DEDENT\"] * pending_dedents)\n                    result.append(\" \" * indent_level + f\"{dedents} {content}\")\n                    pending_dedents = 0\n                else:\n                    result.append(line)\n        \n        # Add any remaining DEDENT tokens at the end\n        if len(indentation_stack) > 1:\n            for _ in range(len(indentation_stack) - 1):\n                result.append(\"DEDENT\")\n        \n        return '\\n'.join(result)\n    \n    def _create_indentation_error(self, current_indent: int, line: int, column: int) -> Dict[str, Any]:\n        \"\"\"\n        Create a detailed error message for indentation issues,\n        designed to be AI-friendly with suggestions.\n        \n        Args:\n            current_indent: The current indentation level\n            line: Line number with the error\n            column: Column number with the error\n            \n        Returns:\n            An error object with details and suggestions\n        \"\"\"\n        valid_indents = \", \".join(map(str, self.indents))\n        \n        # Find closest valid indentation\n        closest_indent = min(self.indents, key=lambda x: abs(x - current_indent))\n        \n        # Basic error message\n        message = f\"Indentation error at line {line}:{column}: Found indentation of {current_indent} spaces, expected one of [{valid_indents}] spaces.\"\n        \n        # Add AI-friendly suggestion\n        if current_indent > self.indents[-1]:\n            suggestion = f\"Indent to exactly {self.indents[-1]} spaces at this level.\"\n        else:\n            suggestion = f\"Dedent to exactly {closest_indent} spaces to align with the correct block.\"\n        \n        # Add code example\n        if current_indent > self.indents[-1]:\n            example = f\"# Instead of this:\\n\" + \\\n                      f\"{'    ' * (current_indent // 4)}statement\\n\\n\" + \\\n                      f\"# Use this:\\n\" + \\\n                      f\"{'    ' * (self.indents[-1] // 4)}statement\"\n        else:\n            example = f\"# Instead of this:\\n\" + \\\n                      f\"{'    ' * (current_indent // 4)}statement\\n\\n\" + \\\n                      f\"# Use this:\\n\" + \\\n                      f\"{'    ' * (closest_indent // 4)}statement\"\n        \n        return {\n            \"type\": \"IndentationError\",\n            \"message\": message,\n            \"suggestion\": suggestion,\n            \"example\": example,\n            \"line\": line,\n            \"column\": column,\n            \"current_indent\": current_indent,\n            \"valid_indents\": self.indents.copy()\n        }\n\n\n# Legacy IndentationLexer class for backward compatibility\nclass IndentationLexer:\n    \"\"\"\n    Legacy class for backward compatibility. \n    Please use AegisIndentationLexer instead.\n    \"\"\"\n    \n    def __init__(self, lexer):\n        self.lexer = lexer\n        self.tokens = []\n        self.indents = [0]  # Initial indent level is 0\n        self.emit_eof = True\n        self.aegis_lexer = AegisIndentationLexer(lexer)\n    \n    def get_all_tokens(self) -> List[Token]:\n        \"\"\"\n        Legacy method for backward compatibility.\n        \"\"\"\n        raise NotImplementedError(\"This method is deprecated. Use AegisIndentationLexer.process_indentation instead.\")\n    \n    def _process_tokens(self, tokens: List[Token]) -> List[Token]:\n        \"\"\"Legacy method, use AegisIndentationLexer instead.\"\"\"\n        raise NotImplementedError(\"This method is deprecated. Use AegisIndentationLexer.process_indentation instead.\")\n    \n    def _get_indent_size(self, token: Token) -> int:\n        \"\"\"Legacy method, use AegisIndentationLexer instead.\"\"\"\n        raise NotImplementedError(\"This method is deprecated. Use AegisIndentationLexer.process_indentation instead.\")\n    \n    def _create_token(self, token_type: int, text: str, copy_from: Token = None) -> Token:\n        \"\"\"Legacy method, use AegisIndentationLexer instead.\"\"\"\n        raise NotImplementedError(\"This method is deprecated. Use AegisIndentationLexer.process_indentation instead.\") ", "size": 7753, "lastModified": 1741351853.5071173, "moduleContext": "src/lexer", "structure": {"classes": ["IndentationLexer", "for", "AegisIndentationLexer"], "functions": ["get_all_tokens", "__init__", "_process_tokens", "_get_indent_size", "process_indentation", "_create_token", "_create_indentation_error"], "imports": ["Token", "AegisLangLexer", "List", "the", "antlr4", "typing"]}, "stats": {"line_count": 182, "function_count": 7, "class_count": 3, "complexity_estimate": 31}, "contentHash": "0be2e446fd37eaeb259b902e55dc7e7d"}
{"filePath": "src/lexer/lexer.py", "language": "Python", "content": "import re\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n# -------------------------------\n# Lexer Implementation\n# -------------------------------\n# Token definitions: keywords, types, operators, symbols.\n# A lex() function that scans the source code and returns tokens.\nTOKEN_TYPES = {\n    \"KEYWORDS\": [\n        \"fn\",\n        \"struct\",\n        \"enum\",\n        \"return\",\n        \"if\",\n        \"else\",\n        \"elif\",\n        \"for\",\n        \"while\",\n        \"module\",\n        \"let\",\n        \"mut\",\n        \"async\",\n        \"await\",\n        \"task\",\n    ],\n    \"TYPES\": [\n        \"int\",\n        \"float\",\n        \"bool\",\n        \"char\",\n        \"string\",\n        \"List\",\n        \"Array\",\n        \"Map\",\n        \"Option\",\n        \"Result\",\n    ],\n    \"OPERATORS\": [\n        \"+\",\n        \"-\",\n        \"*\",\n        \"/\",\n        \"=\",\n        \"==\",\n        \"!=\",\n        \">=\",\n        \"<=\",\n        \"<\",\n        \">\",\n        \"->\",\n        \"::\",\n    ],\n    \"SYMBOLS\": [\":\", \",\", \"(\", \")\", \"[\", \"]\", \"{\", \"}\", \"...\", \"parallel\"],\n}\n\nTOKEN_PATTERNS = [\n    (\n        r\"\\b(fn|struct|enum|return|if|else|elif|for|while|module|let|mut|async|await|task)\\b\",\n        \"KEYWORD\",\n    ),\n    (r\"\\b(int|float|bool|char|string|List|Array|Map|Option|Result)\\b\", \"TYPE\"),\n    (r\"\\b[0-9]+\\b\", \"NUMBER\"),\n    (r\"\\b[a-zA-Z_][a-zA-Z0-9_]*\\b\", \"IDENTIFIER\"),\n    (r'\".*?\"', \"STRING\"),\n    (r\"#[^\\n]*\", \"COMMENT\"),\n    (r\"[\\+\\-\\*/=<>!:]+\", \"OPERATOR\"),\n    (r\"[\\(\\)\\[\\]\\{\\},:]\", \"SYMBOL\"),\n    (r\"\\s+\", None),  # Ignore whitespace\n]\n\n\n# -------------------------------\n# Lexer Function\n# -------------------------------\ndef lex(input_code):\n    \"\"\"Enhanced lexer with better error handling and context.\"\"\"\n    logger.info(\"Starting lexer...\")\n    tokens = []\n    line_num = 1\n    column = 1\n    input_len = len(input_code)\n    idx = 0\n\n    while idx < input_len:\n        match_found = False\n\n        # Track line numbers\n        if input_code[idx] == \"\\n\":\n            line_num += 1\n            column = 1\n            idx += 1\n            continue\n\n        for pattern, token_type in TOKEN_PATTERNS:\n            match = re.match(pattern, input_code[idx:])\n            if match:\n                if token_type:  # Skip whitespace\n                    tokens.append((token_type, match.group(0), line_num, column))\n                    logger.debug(f\"Token: {token_type}, {match.group(0)}, {line_num}, {column}\")\n                idx += len(match.group(0))\n                column += len(match.group(0))\n                match_found = True\n                break\n\n        if not match_found:\n            logger.error(f\"No match found for line {line_num}, column {column}\")\n            # Extract a snippet of the problematic code for context\n            context_start = max(0, idx - 10)\n            context_end = min(len(input_code), idx + 10)\n            context = input_code[context_start:context_end]\n            position_marker = \" \" * (min(10, idx - context_start)) + \"^\"\n\n            error_msg = (\n                f\"Lexical error at line {line_num}, column {column}:\\n\"\n                f\"{context}\\n{position_marker}\\n\"\n                f\"Unexpected character: '{input_code[idx]}'\"\n            )\n            raise SyntaxError(error_msg)\n    logger.debug(f\"Lexer tokens: {len(tokens)} tokens.\")\n    logger.info(\"Lexer completed successfully.\")\n    return tokens\n\n\n# Lexing with indentation (if you want indentation-based blocks).\n# By default, you don't need this for your current grammar. If you keep it, define `lex_line`.\ndef lex_line(line_content, line_num):\n    \"\"\"\n    A helper to tokenize a single line (used by lex_with_indentation).\n    Mirrors the `lex` logic but for one line.\n    \"\"\"\n    logger.info(\"Starting lex_line...\")\n    tokens = []\n    idx = 0\n    column = 1\n    length = len(line_content)\n\n    while idx < length:\n        match_found = False\n        if line_content[idx] == \"\\n\":\n            # not strictly needed here\n            idx += 1\n            column = 1\n            continue\n\n        for pattern, token_type in TOKEN_PATTERNS:\n            match = re.match(pattern, line_content[idx:])\n            if match:\n                if token_type:\n                    tokens.append((token_type, match.group(0), line_num, column))\n                idx += len(match.group(0))\n                column += len(match.group(0))\n                match_found = True\n                break\n\n        if not match_found:\n            logger.error(f\"No match found for line {line_num}, column {column}\")\n            context_start = max(0, idx - 10)\n            context_end = min(length, idx + 10)\n            context = line_content[context_start:context_end]\n            position_marker = \" \" * (min(10, idx - context_start)) + \"^\"\n\n            error_msg = (\n                f\"Lexical error at line {line_num}, column {column}:\\n\"\n                f\"{context}\\n{position_marker}\\n\"\n                f\"Unexpected character: '{line_content[idx]}'\"\n            )\n            raise SyntaxError(error_msg)\n    logger.debug(f\"Lexed line {line_num}: {tokens}\")\n    return tokens\n\n\ndef lex_with_indentation(input_code):\n    \"\"\"Lexer that handles indentation levels for scoping.\"\"\"\n    logger.info(\"Starting lex_with_indentation...\")\n    tokens = []\n    lines = input_code.splitlines()\n\n    # Track indentation stack\n    indent_stack = [0]  # Start with 0 indentation\n\n    for line_num, line in enumerate(lines, 1):\n        # Skip empty lines\n        if not line.strip():\n            continue\n\n        # Calculate indentation level\n        indent = len(line) - len(line.lstrip())\n        line_content = line.lstrip()\n\n        # Skip comment-only lines\n        if line_content.startswith(\"#\"):\n            continue\n\n        # Handle indentation changes\n        if indent > indent_stack[-1]:\n            # Indentation increased - push new level and emit INDENT token\n            indent_stack.append(indent)\n            tokens.append((\"INDENT\", \"\", line_num, 0))\n        elif indent < indent_stack[-1]:\n            # Indentation decreased - pop levels and emit DEDENT tokens\n            while indent < indent_stack[-1]:\n                indent_stack.pop()\n                tokens.append((\"DEDENT\", \"\", line_num, 0))\n\n            # Ensure indent level matches exactly one of the previous levels\n            if indent != indent_stack[-1]:\n                # invalid indent\n                raise IndentationError(\n                    f\"Line {line_num}: Invalid indentation level (got {indent}, expected {indent_stack[-1]})\"\n                )\n\n        # Now lex the actual content of the line\n        line_tokens = lex_line(line_content, line_num)\n        tokens.extend(line_tokens)\n\n        # Add implicit line end\n        tokens.append((\"NEWLINE\", \"\\n\", line_num, len(line)))\n\n    # Add any remaining DEDENT tokens at the end of the file\n    while len(indent_stack) > 1:\n        indent_stack.pop()\n        tokens.append((\"DEDENT\", \"\", len(lines) + 1, 0))\n\n    logger.debug(f\"Lexed with indentation: {tokens}\")\n    return tokens", "size": 6994, "lastModified": 1741346226.8945813, "moduleContext": "src/lexer", "structure": {"classes": [], "functions": ["lex_with_indentation", "lex_line", "lex"], "imports": ["utils", "get_logger", "re"]}, "stats": {"line_count": 227, "function_count": 3, "class_count": 0, "complexity_estimate": 52}, "contentHash": "5f9cca99d33f3dd63a51431c1cf60681"}
{"filePath": "src/wasm/wasm_compiler.py", "language": "Python", "content": "from llvmlite import ir\n\n\n# Enabling Compilation to WebAssembly (WASM) for AegisLang\nclass WebAssemblyCompiler:\n    \"\"\"Compiles AegisLang LLVM IR into WebAssembly (WASM) bytecode.\"\"\"\n\n    def __init__(self, llvm_ir):\n        self.llvm_ir = llvm_ir\n\n    def compile_to_wasm(self):\n        \"\"\"Compiles the LLVM IR to WASM.\"\"\"\n        # Create a WASM-compatible target machine\n        target_triple = \"wasm32-unknown-unknown\"\n        target = binding.Target.from_triple(target_triple)\n        target_machine = target.create_target_machine(codemodel=\"default\")\n\n        # Convert LLVM IR to WASM binary format\n        llvm_module = binding.parse_assembly(self.llvm_ir)\n        llvm_module.verify()\n\n        object_code = target_machine.emit_object(llvm_module)\n\n        # Save the compiled WASM file\n        wasm_filename = \"output.wasm\"\n        with open(wasm_filename, \"wb\") as wasm_file:\n            wasm_file.write(object_code)\n\n        return f\"WebAssembly compilation successful. Output saved as '{wasm_filename}'.\"\n\n\n# Generating WebAssembly-Compatible LLVM IR\n\n\nclass WebAssemblyIRGenerator(CodeGenerator):\n    \"\"\"Generates WebAssembly-compatible LLVM IR for AegisLang.\"\"\"\n\n    def __init__(self, ast):\n        super().__init__(ast)\n        self.module.triple = \"wasm32-unknown-unknown\"\n\n    def generate_function(self, function_node):\n        \"\"\"Generates WASM-compatible LLVM function definitions.\"\"\"\n        func_name = function_node.value\n        param_list = function_node.children[0].value  # [(param_name, param_type), ...]\n        return_type = function_node.children[1].value\n\n        # Convert function types (WASM supports only specific types)\n        llvm_return_type = self.get_wasm_compatible_type(return_type)\n        llvm_param_types = [\n            self.get_wasm_compatible_type(ptype) for _, ptype in param_list\n        ]\n\n        # Create function signature\n        func_type = ir.FunctionType(llvm_return_type, llvm_param_types)\n        func = ir.Function(self.module, func_type, name=func_name)\n\n        # Register in symbol table\n        self.symbol_table[func_name] = func\n\n    def get_wasm_compatible_type(self, aegis_type):\n        \"\"\"Maps AegisLang types to WASM-compatible LLVM types.\"\"\"\n        wasm_type_map = {\n            \"int\": ir.IntType(32),  # WebAssembly prefers 32-bit integers\n            \"float\": ir.FloatType(),\n            \"bool\": ir.IntType(1),\n            \"string\": ir.PointerType(\n                ir.IntType(8)\n            ),  # WASM handles strings as memory pointers\n        }\n        return wasm_type_map.get(\n            aegis_type, ir.VoidType()\n        )  # Default to void if unknown\n", "size": 2639, "lastModified": 1741345565.6483417, "moduleContext": "src/wasm", "structure": {"classes": ["WebAssemblyIRGenerator", "WebAssemblyCompiler"], "functions": ["get_wasm_compatible_type", "generate_function", "__init__", "compile_to_wasm"], "imports": ["ir", "llvmlite"]}, "stats": {"line_count": 74, "function_count": 4, "class_count": 2, "complexity_estimate": 7}, "contentHash": "f4b7a52f4a2947841454571ee4599e6b"}
{"filePath": "src/runtime/runtime.py", "language": "Python", "content": "", "size": 0, "lastModified": 1741346365.0840003, "moduleContext": "src/runtime", "structure": {"classes": [], "functions": [], "imports": []}, "stats": {"line_count": 1, "function_count": 0, "class_count": 0, "complexity_estimate": 0}, "contentHash": "d41d8cd98f00b204e9800998ecf8427e"}
{"filePath": "src/parser/AegisLang.g4", "language": "unknown", "content": "grammar AegisLang;\n\n/**\n * Aegis - AI-Optimized Programming Language Grammar\n * This grammar file defines the syntax for the Aegis programming language,\n * which is specifically designed for deterministic and error-free AI code generation.\n * \n * @ai:best-practices Follow these conventions for AI-optimized code generation:\n * - Use clear, descriptive names that convey purpose\n * - Prefer explicit type annotations over inference\n * - Create small, focused modules with clear responsibilities\n * - Document all public interfaces with /// comments\n */\n\n// Parser Rules\n/**\n * The entry point for an Aegis program.\n * A program consists of one or more module declarations.\n * \n * @ai:preferred Organize code into logical modules with clear responsibilities.\n * Each module should focus on a single domain or feature set.\n */\nprogram\n    : moduleDecl+ EOF\n    ;\n\n/**\n * Module declaration defines a namespace for related code.\n * \n * @ai:naming-convention Use PascalCase for module names.\n * Names should be nouns describing the domain (e.g., UserAuthentication, DataProcessing).\n * \n * Example:\n * /// This module handles user authentication and session management\n * /// @ai:security-reviewed\n * module UserAuthentication:\n *     // module contents\n */\nmoduleDecl\n    : MODULE identifier COLON INDENT (structDecl | enumDecl | fnDecl | constDecl)* DEDENT\n    ;\n\n/**\n * Struct declaration defines a composite data type.\n * \n * @ai:naming-convention Use PascalCase for struct names.\n * Names should be nouns describing the entity (e.g., User, ConfigSettings).\n * \n * @ai:best-practice Keep structs focused with a clear purpose.\n * Prefer immutable fields where possible.\n * \n * Example:\n * /// Represents a user in the system\n * /// @ai:validated\n * struct User:\n *     id: string\n *     name: string\n *     email: string\n */\nstructDecl\n    : STRUCT identifier COLON INDENT fieldDecl* DEDENT\n    ;\n\n/**\n * Field declaration within a struct.\n * \n * @ai:naming-convention Use camelCase for field names.\n * Names should clearly describe the purpose of the field.\n * \n * @ai:best-practice Include a type for every field.\n * Use Option<T> for fields that may be absent rather than null.\n * \n * Example:\n * /// User's unique identifier\n * id: string\n * \n * /// Optional user profile picture\n * profilePicture: Option<string> = None\n */\nfieldDecl\n    : identifier COLON type (ASSIGN expression)?\n    ;\n\n/**\n * Enum declaration defines a type with a fixed set of variants.\n * \n * @ai:naming-convention Use PascalCase for enum names and variants.\n * Enum names should be singular nouns (e.g., Status, UserRole).\n * \n * @ai:best-practice Use enums for representing a fixed set of options.\n * Consider using variant data for related information.\n * \n * Example:\n * /// Represents the status of an order\n * /// @ai:exhaustive-check\n * enum OrderStatus:\n *     Pending\n *     Processing\n *     Shipped(TrackingInfo)\n *     Delivered\n *     Cancelled(string)\n */\nenumDecl\n    : ENUM identifier COLON INDENT enumVariant* DEDENT\n    ;\n\n/**\n * Enum variant declaration.\n * \n * @ai:naming-convention Use PascalCase for variant names.\n * For variants with data, use descriptive names for the data types.\n * \n * Example:\n * /// Order has been shipped with tracking information\n * Shipped(TrackingInfo)\n * \n * /// Order was cancelled with a reason\n * Cancelled(string)\n */\nenumVariant\n    : identifier (LPAREN type (COMMA type)* RPAREN)?\n    ;\n\n/**\n * Function declaration.\n * \n * @ai:naming-convention Use camelCase for function names.\n * Function names should be verbs or verb phrases describing the action.\n * \n * @ai:best-practice Include return type annotations even when returning void.\n * Group related parameters, limit parameter count (<= 5 recommended).\n * \n * Example:\n * /// Authenticates a user and returns a session token\n * /// @ai:security-critical\n * fn authenticateUser(username: string, password: string) -> Result<string, AuthError>:\n *     // function body\n */\nfnDecl\n    : FN identifier LPAREN paramList? RPAREN (ARROW type)? COLON INDENT statement* DEDENT\n    ;\n\n/**\n * Parameter list for function declarations.\n * \n * @ai:best-practice Keep parameter lists short and focused.\n * Use structs to group related parameters if the list gets too long.\n * \n * Example:\n * createUser(name: string, email: string, role: UserRole)\n * \n * // Preferred for many parameters:\n * createUser(userData: UserCreationData)\n */\nparamList\n    : parameter (COMMA parameter)*\n    ;\n\n/**\n * Individual parameter declaration.\n * \n * @ai:naming-convention Use camelCase for parameter names.\n * Names should clearly describe the parameter's purpose.\n * \n * @ai:best-practice Always include type annotations.\n * For optional parameters, use Option<T> rather than nullable types.\n * \n * Example:\n * userId: string\n * options: Option<UserOptions> = None\n */\nparameter\n    : identifier COLON type\n    ;\n\n/**\n * Constant declaration.\n * \n * @ai:naming-convention Use UPPER_SNAKE_CASE for constants.\n * Names should describe the value's purpose.\n * \n * @ai:best-practice Use constants for fixed values that won't change.\n * Include type annotations for clarity.\n * \n * Example:\n * /// Maximum number of login attempts before account lockout\n * /// @ai:security-parameter\n * const MAX_LOGIN_ATTEMPTS: int = 5\n */\nconstDecl\n    : CONST identifier COLON type ASSIGN expression\n    ;\n\n/**\n * Type definition.\n * \n * @ai:best-practice Use the most specific type applicable.\n * Prefer Option<T> over nullable types, and Result<T,E> for fallible operations.\n * \n * Examples:\n * int                           // Simple primitive type\n * User                          // User-defined type\n * Option<User>                  // Optional user (preferred over nullable)\n * Result<User, DatabaseError>   // User or error from database operation\n * [string]                      // Array of strings\n */\ntype\n    : PRIMITIVE_TYPE                                    # primitiveType\n    | identifier                                        # userDefinedType\n    | OPTION LESS_THAN type GREATER_THAN                # optionType\n    | RESULT LESS_THAN type COMMA type GREATER_THAN     # resultType\n    | LBRACKET type RBRACKET                           # arrayType\n    ;\n\n/**\n * Statement definition.\n * \n * @ai:best-practice Keep statements focused and simple.\n * Prefer immutable variables (constants) where possible.\n * Use structured control flow rather than complex expressions.\n */\nstatement\n    : variableDecl\n    | assignmentStmt\n    | returnStmt\n    | ifStmt\n    | forStmt\n    | whileStmt\n    | expressionStmt\n    ;\n\n/**\n * Variable declaration.\n * \n * @ai:naming-convention Use camelCase for variable names.\n * Names should clearly describe the variable's purpose.\n * \n * @ai:best-practice Include type annotations for clarity.\n * Initialize variables at declaration when possible.\n * \n * Example:\n * /// User's authentication token\n * let authToken: string = generateToken(userId)\n * \n * /// Optional user preferences\n * let preferences: Option<UserPreferences> = fetchPreferences(userId)\n */\nvariableDecl\n    : LET identifier COLON type (ASSIGN expression)? \n    ;\n\n/**\n * Assignment statement.\n * \n * @ai:best-practice Minimize reassignment of variables.\n * Prefer let declarations with initialization over separate assignment.\n * \n * Example:\n * counter = counter + 1\n * user.name = newName\n */\nassignmentStmt\n    : expression ASSIGN expression\n    ;\n\n/**\n * Return statement.\n * \n * @ai:best-practice Ensure return types match function declaration.\n * For void functions, use return without an expression.\n * Use Result<T,E> for functions that can fail.\n * \n * Example:\n * return user                             // Return a value\n * return Result.Ok(user)                  // Return success with value\n * return Result.Err(DatabaseError.NotFound) // Return error\n */\nreturnStmt\n    : RETURN expression?\n    ;\n\n/**\n * If statement.\n * \n * @ai:best-practice Keep conditions simple and explicit.\n * Avoid deep nesting; extract complex logic to functions.\n * Consider using match expressions for multi-way conditionals.\n * \n * Example:\n * /// @ai:branch-coverage\n * if user.isAdmin:\n *     // admin logic\n * else if user.hasPermission(Permission.Edit):\n *     // edit logic\n * else:\n *     // regular user logic\n */\nifStmt\n    : IF expression COLON INDENT statement* DEDENT\n      (ELSE IF expression COLON INDENT statement* DEDENT)*\n      (ELSE COLON INDENT statement* DEDENT)?\n    ;\n\n/**\n * For statement for iteration.\n * \n * @ai:best-practice Use for loops for iterating over collections.\n * Keep loop bodies focused; extract complex logic to functions.\n * \n * Example:\n * /// Process each user in the list\n * /// @ai:parallelizable\n * for user in users:\n *     processUser(user)\n */\nforStmt\n    : FOR identifier IN expression COLON INDENT statement* DEDENT\n    ;\n\n/**\n * While statement for conditional loops.\n * \n * @ai:best-practice Include a clear termination condition.\n * Avoid infinite loops; ensure the condition will eventually be false.\n * Consider using a for loop if the number of iterations is known.\n * \n * Example:\n * /// Retry operation until successful or max attempts reached\n * /// @ai:max-iterations=5\n * while retryCount < MAX_RETRIES and not success:\n *     success = attemptOperation()\n *     retryCount = retryCount + 1\n */\nwhileStmt\n    : WHILE expression COLON INDENT statement* DEDENT\n    ;\n\n/**\n * Expression statement.\n * \n * @ai:best-practice Use expression statements for function calls with side effects.\n * Avoid unused expressions.\n * \n * Example:\n * logMessage(\"Operation completed\")\n * database.saveUser(user)\n */\nexpressionStmt\n    : expression\n    ;\n\n/**\n * Expression definition.\n * \n * @ai:best-practice Keep expressions simple and focused.\n * Break complex expressions into smaller, named variables.\n * Use parentheses to clarify precedence in complex expressions.\n */\nexpression\n    : primary                                                # primaryExpr\n    | LPAREN expression RPAREN                               # parenExpr\n    | expression DOT identifier                              # memberAccessExpr\n    | identifier LPAREN expressionList? RPAREN               # constructorOrFunctionExpr\n    | expression LPAREN expressionList? RPAREN               # methodCallExpr\n    | expression LBRACKET expression RBRACKET                # indexExpr\n    | op=(PLUS | MINUS | NOT) expression                     # unaryExpr\n    | expression op=(MUL | DIV | MOD) expression             # multiplicativeExpr\n    | expression op=(PLUS | MINUS) expression                # additiveExpr\n    | expression op=(LESS_THAN | LESS_EQUAL | GREATER_THAN | GREATER_EQUAL) expression # relationalExpr\n    | expression op=(EQUAL | NOT_EQUAL) expression           # equalityExpr\n    | expression AND expression                              # andExpr\n    | expression OR expression                               # orExpr\n    | <assoc=right> expression QUESTION expression COLON expression # conditionalExpr\n    | AWAIT expression                                       # awaitExpr\n    ;\n\n/**\n * Expression list for function calls, method calls, and constructors.\n * \n * @ai:best-practice Use named parameters for clarity in complex function calls.\n * Limit the number of arguments (<= 5 recommended).\n * \n * Example:\n * createUser(\"John Doe\", \"john@example.com\", UserRole.Regular)\n * \n * // Preferred for clarity:\n * createUser(name: \"John Doe\", email: \"john@example.com\", role: UserRole.Regular)\n */\nexpressionList\n    : expression (COMMA expression)*\n    ;\n\n/**\n * Primary expressions (literals and identifiers).\n * \n * @ai:best-practice Use appropriate literal types for values.\n * Consider defining named constants for magic numbers.\n */\nprimary\n    : INTEGER_LITERAL                                       # integerLiteral\n    | FLOAT_LITERAL                                         # floatLiteral\n    | STRING_LITERAL                                        # stringLiteral\n    | BOOLEAN_LITERAL                                       # booleanLiteral\n    | identifier                                            # identifierLiteral\n    | NONE                                                  # noneLiteral\n    | LBRACKET (expression (COMMA expression)*)? RBRACKET   # arrayLiteral\n    ;\n\n/**\n * Identifier definition.\n * \n * @ai:naming-convention Follow these conventions:\n * - PascalCase for types, modules, enums (User, AuthModule)\n * - camelCase for variables, functions, fields (userName, calculateTotal)\n * - UPPER_SNAKE_CASE for constants (MAX_RETRY_COUNT)\n * \n * @ai:best-practice Use clear, descriptive names that convey purpose.\n * Avoid abbreviations unless widely understood.\n */\nidentifier\n    : IDENTIFIER\n    ;\n\n// Lexer Rules\n/**\n * Keywords and tokens for the Aegis language.\n * These define the fundamental building blocks of the language syntax.\n */\nMODULE: 'module';\nSTRUCT: 'struct';\nENUM: 'enum';\nFN: 'fn';\nCONST: 'const';\nLET: 'let';\nRETURN: 'return';\nIF: 'if';\nELSE: 'else';\nFOR: 'for';\nIN: 'in';\nWHILE: 'while';\nAWAIT: 'await';\nOPTION: 'Option';\nRESULT: 'Result';\nNONE: 'None';\nAND: 'and';\nOR: 'or';\n\n/**\n * Primitive types in Aegis.\n * \n * @ai:best-practice Use the most specific type applicable:\n * - int: For integer values\n * - float: For decimal values\n * - bool: For true/false values\n * - string: For text values\n */\nPRIMITIVE_TYPE: 'int' | 'float' | 'bool' | 'string';\nBOOLEAN_LITERAL: 'true' | 'false';\n\n/**\n * Punctuation and operators.\n * These define the syntax for expressions, statements, and declarations.\n */\nCOLON: ':';\nSEMICOLON: ';';\nCOMMA: ',';\nDOT: '.';\nLPAREN: '(';\nRPAREN: ')';\nLBRACE: '{';\nRBRACE: '}';\nLBRACKET: '[';\nRBRACKET: ']';\nARROW: '->';\nASSIGN: '=';\nPLUS: '+';\nMINUS: '-';\nMUL: '*';\nDIV: '/';\nMOD: '%';\nNOT: '!';\nEQUAL: '==';\nNOT_EQUAL: '!=';\nLESS_THAN: '<';\nLESS_EQUAL: '<=';\nGREATER_THAN: '>';\nGREATER_EQUAL: '>=';\nQUESTION: '?';\n\n/**\n * Special tokens for indentation-based syntax.\n * These are inserted by the preprocessor to handle Python-like indentation.\n */\nINDENT: 'INDENT'; // Will be inserted by preprocessor\nDEDENT: 'DEDENT'; // Will be inserted by preprocessor\n\n/**\n * Identifier pattern.\n * \n * @ai:naming-convention Follow these conventions:\n * - PascalCase for types, modules, enums (User, AuthModule)\n * - camelCase for variables, functions, fields (userName, calculateTotal)\n * - UPPER_SNAKE_CASE for constants (MAX_RETRY_COUNT)\n */\nIDENTIFIER: [a-zA-Z_][a-zA-Z0-9_]*;\n\n/**\n * Literal patterns for integers, floats, and strings.\n */\nINTEGER_LITERAL: [0-9]+;\nFLOAT_LITERAL: [0-9]+ '.' [0-9]+;\nSTRING_LITERAL: '\"' (~[\"\\r\\n] | '\\\\\"')* '\"';\n\n/**\n * Whitespace and comments.\n * These are skipped during parsing.\n * \n * @ai:documentation-convention Use '#' for single-line comments.\n * For documentation comments, use the following format:\n * /// This is a documentation comment\n * /// @ai:tag Additional metadata\n */\nWHITESPACE: [ \\t\\r\\n]+ -> skip;\nCOMMENT: '#' ~[\\r\\n]* -> skip;\n\n/**\n * Documentation comment rule (new addition).\n * This allows for structured documentation with special AI tags.\n * \n * Example:\n * /// This function authenticates a user\n * /// @ai:security-reviewed\n * /// @ai:performance-critical\n */\nDOC_COMMENT: '///' ~[\\r\\n]* -> channel(HIDDEN); ", "size": 15221, "lastModified": 1741352357.7968104, "moduleContext": "src/parser", "structure": {}, "stats": {"line_count": 535, "function_count": 0, "class_count": 0, "complexity_estimate": 75}, "contentHash": "69f1c1760b710c5f040dfcf862a48c6b"}
{"filePath": "src/parser/parser.py", "language": "Python", "content": "from src.lexer.lexer import lex\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n# -------------------------------\n# Parser Implementation\n# -------------------------------\n# A TokenStream class to manage tokens.\n# An ASTNode class to build the abstract syntax tree.\n# An AegisParser that produces the AST from tokens.\nclass TokenStream:\n    \"\"\"A simple stream to process tokens sequentially.\"\"\"\n    def __init__(self, tokens):\n        logger.info(\"Starting TokenStream...\")\n        self.tokens = tokens\n        self.index = 0\n\n    def peek(self):\n        \"\"\"Returns the current token without consuming it.\"\"\"\n        logger.debug(f\"Peeking token: {self.tokens[self.index]}\")\n        if self.index < len(self.tokens):\n            return self.tokens[self.index]\n        logger.warning(\"No more tokens to peek.\")\n        return None\n\n    def consume(self):\n        \"\"\"Consumes the current token and moves to the next.\"\"\"\n        logger.info(\"Consuming token...\")\n        token = self.peek()\n        self.index += 1\n        logger.debug(f\"Consumed token: {token}\")\n        return token\n\n    def expect(self, expected_type):\n        \"\"\"Consumes and verifies a token type.\"\"\"\n        logger.info(\"Expecting token...\")\n        token = self.consume()\n        if token is None or token[0] != expected_type:\n            raise SyntaxError(f\"Expected {expected_type}, but got {token}\")\n        logger.debug(f\"Expected token: {token}\")\n        return token\n\n\nclass ASTNode:\n    \"\"\"Base class for AST nodes.\"\"\"\n    def __init__(self, node_type, value=None):\n        logger.info(\"Initializing ASTNode...\")\n        self.node_type = node_type\n        self.value = value\n        self.children = []\n    def add_child(self, child):\n        self.children.append(child)\n    def __repr__(self):\n        logger.debug(f\"ASTNode: {self.node_type}({self.value}, children={self.children})\")\n        return f\"{self.node_type}({self.value}, children={self.children})\"\n\n\nclass AegisParser:\n    \"\"\"Enhanced parser with improved error handling.\"\"\"\n    def __init__(self, tokens):\n        logger.info(\"Initializing AegisParser...\")\n        self.tokens = TokenStream(tokens)\n\n    def parse_module(self):\n        \"\"\"Parses a module declaration.\"\"\"\n        logger.info(\"Parsing module...\")\n        self.tokens.expect(\"KEYWORD\")  # \"module\"\n        module_name = self.tokens.expect(\"IDENTIFIER\")[1]\n        self.tokens.expect(\"SYMBOL\")  # \":\" correctly defined as SYMBOL\n        module_node = ASTNode(\"Module\", module_name)\n        logger.debug(f\"Module parsed with name: {module_name}\")\n\n        # parse children\n        while self.tokens.peek() and self.tokens.peek()[0] == \"KEYWORD\":\n            keyword = self.tokens.peek()[1]\n            if keyword == \"struct\":\n                module_node.add_child(self.parse_struct())\n            elif keyword == \"fn\":\n                module_node.add_child(self.parse_function())\n            else:\n                break\n        logger.debug(f\"Parsed module: {module_node}\")\n        return module_node\n\n    def parse_struct(self):\n        \"\"\"Parses a struct declaration.\"\"\"  \n        logger.info(\"Parsing struct...\")\n        self.tokens.expect(\"KEYWORD\")  # \"struct\"\n        struct_name = self.tokens.expect(\"IDENTIFIER\")[1]\n        self.tokens.expect(\"OPERATOR\")  # \":\"\n        struct_node = ASTNode(\"Struct\", struct_name)\n\n        # parse fields\n        while self.tokens.peek() and self.tokens.peek()[0] == \"IDENTIFIER\":\n            field_name = self.tokens.expect(\"IDENTIFIER\")[1]\n            self.tokens.expect(\"OPERATOR\")  # \":\"\n            field_type = self.tokens.expect(\"TYPE\")[1]\n            struct_node.add_child(ASTNode(\"Field\", (field_name, field_type)))\n        logger.debug(f\"Parsed struct: {struct_node}\")\n        return struct_node\n\n    def parse_function(self):\n        \"\"\"Parses a function declaration.\"\"\"\n        logger.info(\"Parsing function...\")\n        \"\"\"fn <Name>(<Params>) -> <ReturnType>\"\"\"\n        self.tokens.expect(\"KEYWORD\")  # \"fn\"\n        function_name = self.tokens.expect(\"IDENTIFIER\")[1]\n        self.tokens.expect(\"SYMBOL\")  # \"(\"\n        params = []\n        # parse params\n        while self.tokens.peek() and self.tokens.peek()[0] == \"IDENTIFIER\":\n            param_name = self.tokens.expect(\"IDENTIFIER\")[1]\n            self.tokens.expect(\"OPERATOR\")  # \":\"\n            token = self.tokens.peek()\n            if token[0] == \"TYPE\":\n                param_type = self.tokens.expect(\"TYPE\")[1]\n            else:\n                # user-defined type\n                param_type = self.tokens.expect(\"IDENTIFIER\")[1]\n            params.append((param_name, param_type))\n            if self.tokens.peek() and self.tokens.peek()[0] == \"SYMBOL\":\n                if self.tokens.peek()[1] == \")\":\n                    break\n                self.tokens.expect(\"SYMBOL\")  # \",\"\n        self.tokens.expect(\"SYMBOL\")  # \")\"\n        self.tokens.expect(\"OPERATOR\")  # \"->\"\n        # Allow both built-in types and user-defined types\n        token = self.tokens.peek()\n        if token[0] == \"TYPE\":\n            return_type = self.tokens.expect(\"TYPE\")[1]\n        else:\n            return_type = self.tokens.expect(\"IDENTIFIER\")[1]\n        self.tokens.expect(\"OPERATOR\")  # \":\"\n        func_node = ASTNode(\"Function\", function_name)\n        func_node.add_child(ASTNode(\"Parameters\", params))\n        func_node.add_child(ASTNode(\"ReturnType\", return_type))\n        logger.debug(f\"Parsed function: {func_node}\")\n        return func_node\n\n    def parse_block(self):\n        \"\"\"Parse an indentation-based block.\"\"\"\n        logger.info(\"Parsing block...\")\n        self.tokens.expect(\"INDENT\", context=\"block\")\n        block_nodes = []\n        while self.tokens.peek() and self.tokens.peek()[0] != \"DEDENT\":\n            # Parse statements in the block\n            if self.tokens.peek()[0] == \"KEYWORD\":\n                keyword = self.tokens.peek()[1]\n                if keyword == \"if\":\n                    block_nodes.append(self.parse_if_statement())\n                elif keyword == \"while\":\n                    block_nodes.append(self.parse_while_statement())\n                elif keyword == \"return\":\n                    block_nodes.append(self.parse_return_statement())\n                # Add other statement types as needed\n            elif self.tokens.peek()[0] == \"IDENTIFIER\":\n                block_nodes.append(self.parse_expression_statement())\n\n            # Expect a newline after each statement\n            self.tokens.expect(\"NEWLINE\", context=\"statement\")\n        self.tokens.expect(\"DEDENT\", context=\"end of block\")\n        logger.debug(f\"Parsed block: {block_nodes}\")\n        return block_nodes\n\n    def parse_if_statement(self):\n        logger.warning(\"parse_if_statement not implemented yet.\")\n        pass  # TODO: implement\n\n    def parse_while_statement(self):\n        logger.warning(\"parse_while_statement not implemented yet.\")\n        pass  # TODO: implement\n\n    def parse_return_statement(self):\n        logger.warning(\"parse_return_statement not implemented yet.\")\n        pass  # TODO: implement\n\n    def parse(self):\n        \"\"\"Parses the entire code into an AST.\"\"\"\n        logger.info(\"Parsing entire code...\")\n        return self.parse_module()\n\n    def expect(self, expected_type, context=None):\n        \"\"\"Expects a token of a specific type with improved error messages.\"\"\"\n        logger.info(\"Expecting token...\")\n        token = self.tokens.consume()\n        if token is None:\n            context_msg = f\" while parsing {context}\" if context else \"\"\n            raise SyntaxError(\n                f\"Unexpected end of file{context_msg}. Expected {expected_type}.\"\n            )\n\n        if token[0] != expected_type:\n            line = token[2] if len(token) > 2 else \"unknown\"\n            column = token[3] if len(token) > 3 else \"unknown\"\n            context_msg = f\" while parsing {context}\" if context else \"\"\n\n            raise SyntaxError(\n                f\"Line {line}, column {column}{context_msg}: \"\n                f\"Expected {expected_type}, but got {token[0]} ('{token[1]}')\"\n            )\n        logger.debug(f\"Expected token: {token}\")\n        return token\n", "size": 8142, "lastModified": 1741346242.352327, "moduleContext": "src/parser", "structure": {"classes": ["TokenStream", "ASTNode", "to", "AegisParser", "for"], "functions": ["consume", "parse", "peek", "parse_return_statement", "parse_struct", "__repr__", "__init__", "parse_block", "parse_if_statement", "parse_while_statement", "parse_module", "parse_function", "expect", "add_child"], "imports": ["tokens", "src", "get_logger", "lex", "utils"]}, "stats": {"line_count": 203, "function_count": 14, "class_count": 5, "complexity_estimate": 53}, "contentHash": "0d0523e0c348397f476702c8a169530e"}
{"filePath": "src/parser/aeigix_ast_visitor.py", "language": "Python", "content": "\"\"\"\nAegisASTVisitor - Abstract Syntax Tree Visitor for Aegis programming language.\n\nThis visitor traverses the AST produced by the parser and creates a structured \nrepresentation that can be used for semantic analysis, IR generation, and code\noptimization. Each method corresponds to a specific node type in the Aegis language.\n\nThe visitor pattern makes it easy to analyze and transform the AST in an organized,\nmaintainable way while preserving the language's strict typing and deterministic \nexecution model.\n\"\"\"\n\nfrom typing import Dict, List, Any, Optional, Union\nfrom dataclasses import dataclass\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass SourcePosition:\n    \"\"\"Represents a position in the source code file\"\"\"\n    line: int\n    column: int\n    file_path: str = \"\"\n\n    def __str__(self) -> str:\n        return f\"{self.file_path}:{self.line}:{self.column}\"\n\nclass AegisASTVisitor:\n    \"\"\"\n    Visitor for traversing Aegis language Abstract Syntax Trees.\n    \n    This visitor implements methods for all language constructs in Aegis,\n    creating a structured representation that preserves the semantic meaning\n    while making it suitable for AI-driven analysis and transformation.\n    \"\"\"\n    \n    def __init__(self, source_file: str = \"\"):\n        \"\"\"\n        Initialize the AST visitor.\n        \n        Args:\n            source_file: Path to the source file being processed\n        \"\"\"\n        self.source_file = source_file\n        self.current_module = None\n        self.errors = []\n        \n    def _make_node_info(self, node_type: str, name: str, \n                       children: List[Any], pos: SourcePosition,\n                       **extra_info) -> Dict[str, Any]:\n        \"\"\"Helper method to create consistent node information dictionaries.\"\"\"\n        info = {\n            \"node_type\": node_type,\n            \"name\": name,\n            \"children\": children,\n            \"position\": pos,\n        }\n        # Add any extra info specific to the node type\n        info.update(extra_info)\n        return info\n    \n    def visit_module(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a module declaration node.\n        \n        In Aegis, modules are top-level containers that group related functionality.\n        They provide namespace isolation and encapsulation.\n        \n        Constraints:\n        - Module names must be unique within a project\n        - Modules can contain structs, enums, functions, and other declarations\n        - Modules can be nested but must follow a logical hierarchy\n        \n        Example in Aegis:\n            module Math:\n                fn add(a: int, b: int) -> int:\n                    return a + b\n        \n        Returns:\n            Dictionary with module information\n        \"\"\"\n        logger.debug(f\"Visiting module: {node.name}\")\n        \n        old_module = self.current_module\n        self.current_module = node.name\n        \n        # Recursively visit all children\n        children = []\n        for item in node.body:\n            children.append(self.visit(item))\n            \n        self.current_module = old_module\n        \n        return self._make_node_info(\n            node_type=\"module\",\n            name=node.name,\n            children=children,\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            exports=node.exports if hasattr(node, \"exports\") else []\n        )\n    \n    def visit_struct(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a struct declaration node.\n        \n        In Aegis, structs are strongly-typed composite data structures.\n        They have named fields with specific types and no nullable fields.\n        \n        Constraints:\n        - Field names must be unique within a struct\n        - All fields must have explicit type annotations\n        - No implicit type conversions or nullable fields without Option<T>\n        - Structs can implement traits and have methods\n        \n        Example in Aegis:\n            struct Point:\n                x: float\n                y: float\n                \n                fn distance(self, other: Point) -> float:\n                    # Function body\n        \n        Returns:\n            Dictionary with struct information\n        \"\"\"\n        logger.debug(f\"Visiting struct: {node.name}\")\n        \n        fields = []\n        methods = []\n        \n        for item in node.body:\n            if hasattr(item, \"type\") and item.type == \"field\":\n                fields.append(self.visit_field(item))\n            elif hasattr(item, \"type\") and item.type == \"function\":\n                methods.append(self.visit_function(item))\n        \n        return self._make_node_info(\n            node_type=\"struct\",\n            name=node.name,\n            children=fields + methods,\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            fields=fields,\n            methods=methods,\n            traits=node.traits if hasattr(node, \"traits\") else []\n        )\n    \n    def visit_enum(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit an enum declaration node.\n        \n        In Aegis, enums represent a type that can be one of several variants.\n        Each variant can optionally contain data. Enums are used for \n        pattern matching and representing states.\n        \n        Constraints:\n        - Variant names must be unique within an enum\n        - Variants can contain typed data fields\n        - Enums can have methods\n        - Enum variants must be exhaustively matched in pattern matching\n        \n        Example in Aegis:\n            enum Result<T, E>:\n                Ok(T)\n                Err(E)\n                \n                fn is_ok(self) -> bool:\n                    # Function body\n        \n        Returns:\n            Dictionary with enum information\n        \"\"\"\n        logger.debug(f\"Visiting enum: {node.name}\")\n        \n        variants = []\n        methods = []\n        \n        for item in node.body:\n            if hasattr(item, \"type\") and item.type == \"variant\":\n                variants.append(self.visit_variant(item))\n            elif hasattr(item, \"type\") and item.type == \"function\":\n                methods.append(self.visit_function(item))\n        \n        return self._make_node_info(\n            node_type=\"enum\",\n            name=node.name,\n            children=variants + methods,\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            variants=variants,\n            methods=methods,\n            type_params=node.type_params if hasattr(node, \"type_params\") else []\n        )\n    \n    def visit_variant(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit an enum variant node.\n        \n        Enum variants can be simple identifiers or can contain data.\n        \n        Example in Aegis:\n            enum Option<T>:\n                Some(T)  # variant with data\n                None     # simple variant\n        \n        Returns:\n            Dictionary with variant information\n        \"\"\"\n        fields = []\n        \n        if hasattr(node, \"fields\") and node.fields:\n            for field in node.fields:\n                fields.append(self.visit_field(field))\n        \n        return self._make_node_info(\n            node_type=\"variant\",\n            name=node.name,\n            children=fields,\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            fields=fields\n        )\n    \n    def visit_field(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a field declaration node (in structs or enum variants).\n        \n        Fields in Aegis have a name and an explicit type annotation.\n        There are no implicit types or nullable fields.\n        \n        Example in Aegis:\n            struct User:\n                name: string\n                age: int\n        \n        Returns:\n            Dictionary with field information\n        \"\"\"\n        type_info = self.visit_type(node.type_annotation)\n        \n        return self._make_node_info(\n            node_type=\"field\",\n            name=node.name,\n            children=[type_info],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            type_annotation=type_info,\n            default_value=self.visit(node.default_value) if hasattr(node, \"default_value\") and node.default_value else None\n        )\n    \n    def visit_function(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a function declaration node.\n        \n        Functions in Aegis have explicit parameter types and return types.\n        They can be regular functions, methods (with 'self' parameter),\n        or async functions.\n        \n        Constraints:\n        - All parameters must have explicit type annotations\n        - Return type must be explicit\n        - Async functions must be marked with 'async' keyword\n        - Methods in structs/enums have implicit 'self' parameter\n        \n        Example in Aegis:\n            fn add(a: int, b: int) -> int:\n                return a + b\n                \n            async fn fetch_data(url: string) -> Result<string, Error>:\n                # Function body\n        \n        Returns:\n            Dictionary with function information\n        \"\"\"\n        logger.debug(f\"Visiting function: {node.name}\")\n        \n        params = []\n        for param in node.params:\n            params.append(self.visit_parameter(param))\n        \n        return_type = self.visit_type(node.return_type) if hasattr(node, \"return_type\") and node.return_type else None\n        \n        body_nodes = []\n        for stmt in node.body:\n            body_nodes.append(self.visit(stmt))\n        \n        return self._make_node_info(\n            node_type=\"function\",\n            name=node.name,\n            children=params + (body_nodes if body_nodes else []),\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            params=params,\n            return_type=return_type,\n            body=body_nodes,\n            is_async=node.is_async if hasattr(node, \"is_async\") else False,\n            is_method=node.is_method if hasattr(node, \"is_method\") else False,\n            visibility=node.visibility if hasattr(node, \"visibility\") else \"public\"\n        )\n    \n    def visit_parameter(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a function parameter node.\n        \n        Parameters in Aegis have a name and an explicit type annotation.\n        \n        Example in Aegis:\n            fn greet(name: string, age: int) -> string:\n                # Function body\n        \n        Returns:\n            Dictionary with parameter information\n        \"\"\"\n        type_info = self.visit_type(node.type_annotation)\n        \n        return self._make_node_info(\n            node_type=\"parameter\",\n            name=node.name,\n            children=[type_info],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            type_annotation=type_info,\n            default_value=self.visit(node.default_value) if hasattr(node, \"default_value\") and node.default_value else None\n        )\n    \n    def visit_type(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a type annotation node.\n        \n        Type annotations in Aegis can be primitive types, user-defined types,\n        or generic types with type parameters.\n        \n        Examples of Aegis types:\n            int\n            string\n            User\n            Option<int>\n            Result<User, Error>\n            fn(int, string) -> bool  # Function type\n        \n        Returns:\n            Dictionary with type information\n        \"\"\"\n        if node is None:\n            return None\n        \n        type_params = []\n        if hasattr(node, \"type_params\") and node.type_params:\n            for param in node.type_params:\n                type_params.append(self.visit_type(param))\n        \n        return self._make_node_info(\n            node_type=\"type\",\n            name=node.name,\n            children=type_params,\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            is_primitive=node.is_primitive if hasattr(node, \"is_primitive\") else False,\n            type_params=type_params\n        )\n    \n    def visit_block(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a block node.\n        \n        Blocks in Aegis are sequences of statements, potentially with their own scope.\n        \n        Example in Aegis:\n            fn example():\n                # This is a block\n                let x: int = 1\n                let y: int = 2\n                return x + y\n        \n        Returns:\n            Dictionary with block information\n        \"\"\"\n        statements = []\n        \n        for stmt in node.statements:\n            statements.append(self.visit(stmt))\n        \n        return self._make_node_info(\n            node_type=\"block\",\n            name=\"\",\n            children=statements,\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            statements=statements\n        )\n    \n    def visit_var_declaration(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a variable declaration node.\n        \n        Variables in Aegis must have explicit type annotations and can be\n        mutable (var) or immutable (let).\n        \n        Constraints:\n        - All variables must have explicit type annotations\n        - Variables can be immutable (let) or mutable (var)\n        - Immutable variables cannot be reassigned\n        \n        Example in Aegis:\n            let x: int = 5  # immutable\n            var y: int = 10  # mutable\n        \n        Returns:\n            Dictionary with variable declaration information\n        \"\"\"\n        type_info = self.visit_type(node.type_annotation)\n        init_value = self.visit(node.value) if hasattr(node, \"value\") and node.value else None\n        \n        return self._make_node_info(\n            node_type=\"var_declaration\",\n            name=node.name,\n            children=[type_info] + ([init_value] if init_value else []),\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            is_mutable=node.is_mutable,\n            type_annotation=type_info,\n            init_value=init_value\n        )\n    \n    def visit_assignment(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit an assignment node.\n        \n        Assignments in Aegis update the value of a mutable variable or a field.\n        \n        Constraints:\n        - The target must be a mutable variable or field\n        - The assigned value must match the target's type\n        - No implicit type conversions\n        \n        Example in Aegis:\n            var x: int = 5\n            x = 10  # assignment\n            user.name = \"Alice\"  # field assignment\n        \n        Returns:\n            Dictionary with assignment information\n        \"\"\"\n        target = self.visit(node.target)\n        value = self.visit(node.value)\n        \n        return self._make_node_info(\n            node_type=\"assignment\",\n            name=\"\",\n            children=[target, value],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            target=target,\n            value=value,\n            operator=node.operator if hasattr(node, \"operator\") else \"=\"\n        )\n    \n    def visit_if_statement(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit an if statement node.\n        \n        If statements in Aegis include a condition and one or more branches.\n        \n        Constraints:\n        - The condition must evaluate to a boolean\n        - Each branch has its own scope\n        \n        Example in Aegis:\n            if x > 5:\n                println(\"x is greater than 5\")\n            elif x > 0:\n                println(\"x is positive but not greater than 5\")\n            else:\n                println(\"x is not positive\")\n        \n        Returns:\n            Dictionary with if statement information\n        \"\"\"\n        condition = self.visit(node.condition)\n        then_block = self.visit(node.then_block)\n        \n        else_block = None\n        if hasattr(node, \"else_block\") and node.else_block:\n            else_block = self.visit(node.else_block)\n        \n        elif_branches = []\n        if hasattr(node, \"elif_branches\") and node.elif_branches:\n            for branch in node.elif_branches:\n                elif_cond = self.visit(branch.condition)\n                elif_block = self.visit(branch.block)\n                elif_branches.append({\"condition\": elif_cond, \"block\": elif_block})\n        \n        return self._make_node_info(\n            node_type=\"if_statement\",\n            name=\"\",\n            children=[condition, then_block] + ([else_block] if else_block else []),\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            condition=condition,\n            then_block=then_block,\n            else_block=else_block,\n            elif_branches=elif_branches\n        )\n    \n    def visit_for_loop(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a for loop node.\n        \n        For loops in Aegis iterate over collections or ranges.\n        \n        Constraints:\n        - Iterator variable type is inferred from the collection\n        - Collection must be iterable\n        \n        Example in Aegis:\n            for i in 0..10:\n                println(i)\n                \n            for item in items:\n                process(item)\n        \n        Returns:\n            Dictionary with for loop information\n        \"\"\"\n        iterator = self.visit_var_declaration(node.iterator) if hasattr(node, \"iterator_type\") else self.visit(node.iterator)\n        iterable = self.visit(node.iterable)\n        body = self.visit(node.body)\n        \n        return self._make_node_info(\n            node_type=\"for_loop\",\n            name=\"\",\n            children=[iterator, iterable, body],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            iterator=iterator,\n            iterable=iterable,\n            body=body\n        )\n    \n    def visit_while_loop(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a while loop node.\n        \n        While loops in Aegis execute a block as long as a condition is true.\n        \n        Constraints:\n        - The condition must evaluate to a boolean\n        \n        Example in Aegis:\n            while x > 0:\n                x = x - 1\n                println(x)\n        \n        Returns:\n            Dictionary with while loop information\n        \"\"\"\n        condition = self.visit(node.condition)\n        body = self.visit(node.body)\n        \n        return self._make_node_info(\n            node_type=\"while_loop\",\n            name=\"\",\n            children=[condition, body],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            condition=condition,\n            body=body\n        )\n    \n    def visit_return_statement(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a return statement node.\n        \n        Return statements in Aegis specify the value to return from a function.\n        \n        Constraints:\n        - The returned value must match the function's return type\n        - A function with a non-void return type must return a value on all paths\n        \n        Example in Aegis:\n            fn add(a: int, b: int) -> int:\n                return a + b\n        \n        Returns:\n            Dictionary with return statement information\n        \"\"\"\n        value = self.visit(node.value) if hasattr(node, \"value\") and node.value else None\n        \n        return self._make_node_info(\n            node_type=\"return_statement\",\n            name=\"\",\n            children=[value] if value else [],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            value=value\n        )\n    \n    def visit_binary_op(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a binary operation node.\n        \n        Binary operations in Aegis include arithmetic, comparison, and logical operations.\n        \n        Constraints:\n        - Operands must be compatible with the operation\n        - No implicit type conversions\n        \n        Example in Aegis:\n            x + y\n            a && b\n            i < 10\n        \n        Returns:\n            Dictionary with binary operation information\n        \"\"\"\n        left = self.visit(node.left)\n        right = self.visit(node.right)\n        \n        return self._make_node_info(\n            node_type=\"binary_op\",\n            name=node.operator,\n            children=[left, right],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            operator=node.operator,\n            left=left,\n            right=right\n        )\n    \n    def visit_unary_op(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a unary operation node.\n        \n        Unary operations in Aegis include negation, logical not, etc.\n        \n        Constraints:\n        - Operand must be compatible with the operation\n        \n        Example in Aegis:\n            -x\n            !done\n        \n        Returns:\n            Dictionary with unary operation information\n        \"\"\"\n        operand = self.visit(node.operand)\n        \n        return self._make_node_info(\n            node_type=\"unary_op\",\n            name=node.operator,\n            children=[operand],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            operator=node.operator,\n            operand=operand\n        )\n    \n    def visit_call(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a function call node.\n        \n        Function calls in Aegis invoke functions with arguments.\n        \n        Constraints:\n        - The function must exist and be accessible\n        - The arguments must match the function's parameter types\n        - No implicit type conversions\n        \n        Example in Aegis:\n            add(5, 10)\n            user.get_name()\n            println(\"Hello\")\n        \n        Returns:\n            Dictionary with function call information\n        \"\"\"\n        callee = self.visit(node.callee)\n        \n        args = []\n        for arg in node.args:\n            args.append(self.visit(arg))\n        \n        return self._make_node_info(\n            node_type=\"call\",\n            name=\"\",\n            children=[callee] + args,\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            callee=callee,\n            args=args\n        )\n    \n    def visit_identifier(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit an identifier node.\n        \n        Identifiers in Aegis reference variables, functions, types, etc.\n        \n        Example in Aegis:\n            x\n            add\n            User\n        \n        Returns:\n            Dictionary with identifier information\n        \"\"\"\n        return self._make_node_info(\n            node_type=\"identifier\",\n            name=node.name,\n            children=[],\n            pos=SourcePosition(node.line, node.column, self.source_file)\n        )\n    \n    def visit_member_access(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a member access node.\n        \n        Member access in Aegis is used to access fields and methods of structs.\n        \n        Example in Aegis:\n            user.name\n            point.distance(other_point)\n        \n        Returns:\n            Dictionary with member access information\n        \"\"\"\n        object_expr = self.visit(node.object)\n        \n        return self._make_node_info(\n            node_type=\"member_access\",\n            name=node.member,\n            children=[object_expr],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            object=object_expr,\n            member=node.member\n        )\n    \n    def visit_literal(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a literal value node.\n        \n        Literals in Aegis include numeric values, strings, booleans, etc.\n        \n        Examples in Aegis:\n            42        # integer literal\n            3.14      # float literal\n            \"hello\"   # string literal\n            true      # boolean literal\n        \n        Returns:\n            Dictionary with literal information\n        \"\"\"\n        return self._make_node_info(\n            node_type=\"literal\",\n            name=str(node.value),\n            children=[],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            value=node.value,\n            literal_type=node.literal_type\n        )\n    \n    def visit_match_statement(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a match statement node.\n        \n        Match statements in Aegis provide pattern matching on values, particularly enums.\n        \n        Constraints:\n        - Must be exhaustive (cover all possible cases)\n        - Each branch has its own scope\n        \n        Example in Aegis:\n            match result:\n                Ok(value) => println(\"Success: {}\", value)\n                Err(e) => println(\"Error: {}\", e)\n        \n        Returns:\n            Dictionary with match statement information\n        \"\"\"\n        subject = self.visit(node.subject)\n        \n        branches = []\n        for branch in node.branches:\n            pattern = self.visit(branch.pattern)\n            body = self.visit(branch.body)\n            \n            branches.append({\n                \"pattern\": pattern,\n                \"body\": body,\n                \"guard\": self.visit(branch.guard) if hasattr(branch, \"guard\") and branch.guard else None\n            })\n        \n        return self._make_node_info(\n            node_type=\"match_statement\",\n            name=\"\",\n            children=[subject],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            subject=subject,\n            branches=branches\n        )\n    \n    def visit_trait(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a trait declaration node.\n        \n        Traits in Aegis define interfaces that types can implement.\n        \n        Constraints:\n        - Trait names must be unique within a module\n        - Traits can contain function signatures and default implementations\n        \n        Example in Aegis:\n            trait Printable:\n                fn to_string(self) -> string\n                \n                fn print(self):\n                    println(self.to_string())\n        \n        Returns:\n            Dictionary with trait information\n        \"\"\"\n        methods = []\n        \n        for item in node.methods:\n            methods.append(self.visit_function(item))\n        \n        return self._make_node_info(\n            node_type=\"trait\",\n            name=node.name,\n            children=methods,\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            methods=methods,\n            type_params=node.type_params if hasattr(node, \"type_params\") else []\n        )\n    \n    def visit_impl(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a trait implementation node.\n        \n        Impl blocks in Aegis implement traits for specific types.\n        \n        Constraints:\n        - Must implement all methods required by the trait\n        - Method signatures must match trait specifications\n        \n        Example in Aegis:\n            impl Printable for User:\n                fn to_string(self) -> string:\n                    return \"User {self.name}\"\n        \n        Returns:\n            Dictionary with implementation information\n        \"\"\"\n        methods = []\n        \n        for item in node.methods:\n            methods.append(self.visit_function(item))\n        \n        return self._make_node_info(\n            node_type=\"impl\",\n            name=\"\",\n            children=methods,\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            trait_name=node.trait_name if hasattr(node, \"trait_name\") else None,\n            type_name=node.type_name,\n            methods=methods\n        )\n    \n    def visit_import(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit an import statement node.\n        \n        Import statements in Aegis bring modules, types, and functions into scope.\n        \n        Constraints:\n        - Imported entities must exist\n        - Imports can be selective or entire modules\n        \n        Example in Aegis:\n            import Math\n            import IO.{println, readln}\n            import UserSystem.User as AppUser\n        \n        Returns:\n            Dictionary with import statement information\n        \"\"\"\n        return self._make_node_info(\n            node_type=\"import\",\n            name=node.module_path,\n            children=[],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            module_path=node.module_path,\n            items=node.items if hasattr(node, \"items\") else [],\n            alias=node.alias if hasattr(node, \"alias\") else None\n        )\n    \n    def visit_async_await(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit an await expression node.\n        \n        Await expressions in Aegis are used inside async functions to wait for\n        asynchronous operations to complete.\n        \n        Constraints:\n        - Can only be used inside async functions\n        - The awaited expression must be awaitable (Task or Future)\n        \n        Example in Aegis:\n            async fn fetch_data() -> string:\n                let response = await http.get(\"https://example.com\")\n                return response.body\n        \n        Returns:\n            Dictionary with await expression information\n        \"\"\"\n        expression = self.visit(node.expression)\n        \n        return self._make_node_info(\n            node_type=\"await_expression\",\n            name=\"\",\n            children=[expression],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            expression=expression\n        )\n    \n    def visit_task_spawn(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Visit a task spawn node.\n        \n        Task spawning in Aegis creates a new concurrent task.\n        \n        Example in Aegis:\n            let t = task:\n                heavy_computation()\n            \n            # later\n            let result = await t\n        \n        Returns:\n            Dictionary with task spawn information\n        \"\"\"\n        body = self.visit(node.body)\n        \n        return self._make_node_info(\n            node_type=\"task_spawn\",\n            name=\"\",\n            children=[body],\n            pos=SourcePosition(node.line, node.column, self.source_file),\n            body=body\n        )\n    \n    def visit(self, node) -> Dict[str, Any]:\n        \"\"\"\n        Generic visit method that dispatches to the appropriate specific visit method.\n        \n        Args:\n            node: The AST node to visit\n            \n        Returns:\n            Visited node information as a dictionary\n        \"\"\"\n        if node is None:\n            return None\n        \n        # Dispatch based on node type\n        if hasattr(node, \"type\"):\n            method_name = f\"visit_{node.type}\"\n            if hasattr(self, method_name):\n                return getattr(self, method_name)(node)\n            else:\n                logger.warning(f\"No visitor method for node type: {node.type}\")\n                return {\n                    \"node_type\": node.type,\n                    \"name\": getattr(node, \"name\", \"\"),\n                    \"children\": [],\n                    \"position\": SourcePosition(\n                        getattr(node, \"line\", 0),\n                        getattr(node, \"column\", 0),\n                        self.source_file\n                    )\n                }\n        \n        # Fallback for unknown node types\n        logger.warning(f\"Unknown node type: {type(node)}\")\n        return {\n            \"node_type\": \"unknown\",\n            \"name\": str(node),\n            \"children\": [],\n            \"position\": SourcePosition(0, 0, self.source_file)\n        }\n", "size": 32001, "lastModified": 1741355055.371492, "moduleContext": "src/parser", "structure": {"classes": ["import", "AegisASTVisitor", "class"], "functions": ["visit_member_access", "_make_node_info", "visit_var_declaration", "visit_import", "visit_async_await", "__init__", "visit_return_statement", "visit_if_statement", "visit_unary_op", "__str__", "visit", "visit_literal", "visit_struct", "visit_block", "visit_assignment", "visit_parameter", "visit_for_loop", "visit_match_statement", "visit_function", "visit_binary_op", "visit_field", "visit_variant", "visit_enum", "visit_task_spawn", "visit_call", "visit_module", "visit_type", "visit_trait", "visit_while_loop", "visit_impl", "visit_identifier"], "imports": ["logging", "dataclass", "IO", "dataclasses", "statement", "the", "Math", "Dict", "a", "UserSystem", "typing"]}, "stats": {"line_count": 975, "function_count": 31, "class_count": 3, "complexity_estimate": 150}, "contentHash": "3768b7e4467479f9aea0349b746ef850"}
{"filePath": "src/parser/aegis_parser.py", "language": "Python", "content": "from antlr4 import InputStream, CommonTokenStream, DiagnosticErrorListener\nimport sys\nimport os\nfrom typing import Any, Dict, List, Optional, Union\n\n# Add the generated parser directory to the path\nsys.path.append(os.path.join(os.path.dirname(__file__), 'generated'))\n\n# Add the src directory to the path\ncurrent_dir = os.path.dirname(os.path.abspath(__file__))\nsrc_dir = os.path.dirname(current_dir)\nif src_dir not in sys.path:\n    sys.path.insert(0, src_dir)\n\n# Import the generated ANTLR classes\nfrom AegisLangLexer import AegisLangLexer\nfrom AegisLangParser import AegisLangParser\nfrom AegisLangListener import AegisLangListener\n\n# Import from our own modules\nfrom lexer.indentation_lexer import AegisIndentationLexer\n\n\nclass AegisErrorListener(DiagnosticErrorListener):\n    \"\"\"\n    Custom error listener that provides AI-friendly error messages\n    with suggestions for fixing common issues.\n    \"\"\"\n    \n    def __init__(self):\n        super().__init__()\n        self.errors = []\n        \n    def syntaxError(self, recognizer, offendingSymbol, line, column, msg, e):\n        # Call the parent method to get diagnostic messages\n        super().syntaxError(recognizer, offendingSymbol, line, column, msg, e)\n        \n        # Create AI-friendly error messages\n        if offendingSymbol:\n            error_pos = f\"line {line}:{column}\"\n            error_token = offendingSymbol.text if hasattr(offendingSymbol, 'text') else str(offendingSymbol)\n            \n            # Get expected tokens for better suggestions\n            expected_str = \"valid token\"\n            if recognizer:\n                expected_tokens = []\n                try:\n                    expected_tokens_bitset = recognizer.getExpectedTokens()\n                    if expected_tokens_bitset:\n                        # Try to extract token names differently depending on ANTLR version\n                        if hasattr(expected_tokens_bitset, 'toList'):\n                            for token_id in expected_tokens_bitset.toList():\n                                if token_id < len(recognizer.literalNames):\n                                    token_name = recognizer.literalNames[token_id]\n                                    if token_name:\n                                        expected_tokens.append(token_name)\n                        else:\n                            # Older ANTLR might not have toList but direct iteration\n                            for token_id in expected_tokens_bitset:\n                                if token_id < len(recognizer.literalNames):\n                                    token_name = recognizer.literalNames[token_id]\n                                    if token_name:\n                                        expected_tokens.append(token_name)\n                except Exception:\n                    # If we can't get expected tokens, just use the original message\n                    pass\n                    \n                if expected_tokens:\n                    expected_str = \", \".join(expected_tokens)\n                \n            # Create the error message with suggestion\n            error_msg = f\"Syntax error at {error_pos}: Unexpected '{error_token}', expected {expected_str}\"\n            \n            # Add helpful suggestions based on common error patterns\n            suggestion = self._get_suggestion(error_token, expected_tokens if 'expected_tokens' in locals() else [], line, column)\n            if suggestion:\n                error_msg += f\"\\nSuggestion: {suggestion}\"\n            \n            self.errors.append(error_msg)\n        else:\n            self.errors.append(f\"Syntax error at line {line}:{column}: {msg}\")\n    \n    def _get_suggestion(self, offending_token, expected_tokens, line, column):\n        \"\"\"Generate helpful AI-friendly suggestions based on common errors.\"\"\"\n        if 'INDENT' in expected_tokens:\n            return \"Add an indentation (4 spaces) at the beginning of this line. In Aegis, code blocks must be indented consistently.\"\n        \n        if 'DEDENT' in expected_tokens:\n            return \"Reduce the indentation level for this line to match its parent block.\"\n        \n        if 'COLON' in expected_tokens:\n            return \"Add a colon ':' after this declaration to start a new block.\"\n        \n        if offending_token == 'DEDENT' and 'IDENTIFIER' in expected_tokens:\n            return \"This line is not properly indented. Make sure all lines in the same block have the same indentation level.\"\n            \n        # More specific suggestions could be added here\n        \n        return None\n\n\nclass AegisParser:\n    \"\"\"\n    Main parser for the Aegis programming language.\n    Uses ANTLR4-generated parser and a custom indentation-aware lexer.\n    \"\"\"\n    \n    def __init__(self):\n        self.ast = None\n        self.errors = []\n    \n    def parse(self, input_text: str, filename: str = \"<input>\") -> Dict[str, Any]:\n        \"\"\"\n        Parse the input text and return an AST representation.\n        \n        Args:\n            input_text: The source code to parse\n            filename: Source file name for error reporting\n            \n        Returns:\n            An abstract syntax tree representation as a dictionary\n        \"\"\"\n        # Preprocess indentation\n        indentation_lexer = AegisIndentationLexer(None)  # We don't need the actual lexer for preprocessing\n        preprocessed_text = indentation_lexer.process_indentation(input_text)\n        \n        # Add indentation errors if any\n        self.errors.extend([error[\"message\"] + \"\\n\" + error[\"suggestion\"] \n                           for error in indentation_lexer.indent_errors])\n        \n        # Create the input stream\n        input_stream = InputStream(preprocessed_text)\n        \n        # Set up the lexer and parser\n        lexer = AegisLangLexer(input_stream)\n        lexer.removeErrorListeners()\n        \n        # Create token stream and parser\n        tokens = CommonTokenStream(lexer)\n        parser = AegisLangParser(tokens)\n        \n        # Set up error handling\n        error_listener = AegisErrorListener()\n        parser.removeErrorListeners()\n        parser.addErrorListener(error_listener)\n        \n        # Attempt to parse the input\n        try:\n            # Parse the input text\n            parse_tree = parser.program()\n            \n            # Store any errors that occurred during parsing\n            self.errors.extend(error_listener.errors)\n            \n            # If there were errors, return error information\n            if self.errors:\n                return {\n                    \"type\": \"Program\",\n                    \"modules\": [],\n                    \"errors\": self.errors\n                }\n            \n            # Convert to our own AST format\n            visitor = AegisASTVisitor()\n            self.ast = visitor.visit(parse_tree)\n            \n            return self.ast\n            \n        except Exception as e:\n            # Handle any exceptions that occurred during parsing\n            error_msg = str(e)\n            self.errors.append(f\"Error parsing {filename}: {error_msg}\")\n            \n            return {\n                \"type\": \"Program\",\n                \"modules\": [],\n                \"errors\": self.errors\n            }\n    \n    def parse_file(self, filepath: str) -> Dict[str, Any]:\n        \"\"\"\n        Parse a file and return an AST representation.\n        \n        Args:\n            filepath: Path to the file to parse\n            \n        Returns:\n            An abstract syntax tree representation as a dictionary\n        \"\"\"\n        with open(filepath, 'r') as file:\n            input_text = file.read()\n        return self.parse(input_text, filepath)\n\n\nclass AegisASTVisitor:\n    \"\"\"\n    Visitor class that converts the ANTLR parse tree to a custom AST.\n    \"\"\"\n    \n    def __init__(self):\n        self.symbol_table = {}\n        self.current_module = None\n        self.current_struct = None\n        self.current_function = None\n        self.source_positions = {}  # Track source positions for better error messages\n    \n    def visit(self, ctx):\n        \"\"\"Generic visit method that dispatches to specific methods.\"\"\"\n        if ctx is None:\n            return None\n            \n        # Record source position if available\n        if hasattr(ctx, 'start') and ctx.start:\n            position = {\n                'line': ctx.start.line,\n                'column': ctx.start.column,\n                'start': ctx.start.start,\n                'stop': ctx.stop.stop if ctx.stop else ctx.start.stop\n            }\n            self.source_positions[id(ctx)] = position\n        \n        # Dispatch to appropriate visitor method\n        method_name = f'visit_{ctx.__class__.__name__.lower()}'\n        visitor = getattr(self, method_name, self.visit_fallback)\n        result = visitor(ctx)\n        \n        # Add source position to result if it's a dictionary\n        if isinstance(result, dict) and id(ctx) in self.source_positions:\n            result['position'] = self.source_positions[id(ctx)]\n            \n        return result\n    \n    def visit_fallback(self, ctx):\n        \"\"\"Default fallback if no specific visitor is found.\"\"\"\n        if hasattr(ctx, 'children') and ctx.children:\n            results = [self.visit(child) for child in ctx.children if child is not None]\n            return results[-1] if results else None\n        return None\n    \n    def visit_program(self, ctx):\n        \"\"\"Visit the root program node.\"\"\"\n        modules = []\n        for module_ctx in ctx.moduleDecl():\n            module_ast = self.visit_moduledecl(module_ctx)\n            if module_ast:\n                modules.append(module_ast)\n        return {\"type\": \"Program\", \"modules\": modules}\n    \n    def visit_moduledecl(self, ctx):\n        \"\"\"Visit a module declaration.\"\"\"\n        name = self.visit(ctx.identifier())\n        self.current_module = name\n        \n        # Process module body\n        structs = []\n        enums = []\n        functions = []\n        constants = []\n        \n        # Process each declaration in the module\n        # First, look for struct declarations\n        if hasattr(ctx, 'structDecl') and ctx.structDecl():\n            for struct_ctx in ctx.structDecl():\n                struct_ast = self.visit_structdecl(struct_ctx)\n                if struct_ast:\n                    structs.append(struct_ast)\n        \n        # Look for enum declarations\n        if hasattr(ctx, 'enumDecl') and ctx.enumDecl():\n            for enum_ctx in ctx.enumDecl():\n                enum_ast = self.visit_enumdecl(enum_ctx)\n                if enum_ast:\n                    enums.append(enum_ast)\n        \n        # Look for function declarations\n        if hasattr(ctx, 'fnDecl') and ctx.fnDecl():\n            for fn_ctx in ctx.fnDecl():\n                fn_ast = self.visit_fndecl(fn_ctx)\n                if fn_ast:\n                    functions.append(fn_ast)\n        \n        # Look for constant declarations\n        if hasattr(ctx, 'constDecl') and ctx.constDecl():\n            for const_ctx in ctx.constDecl():\n                const_ast = self.visit_constdecl(const_ctx)\n                if const_ast:\n                    constants.append(const_ast)\n        \n        self.current_module = None\n        \n        return {\n            \"type\": \"Module\",\n            \"name\": name,\n            \"structs\": structs,\n            \"enums\": enums,\n            \"functions\": functions,\n            \"constants\": constants\n        }\n    \n    def visit_structdecl(self, ctx):\n        \"\"\"Visit a struct declaration.\"\"\"\n        name = self.visit(ctx.identifier())\n        self.current_struct = name\n        fields = []\n        \n        # Process fields\n        if hasattr(ctx, 'fieldDecl') and ctx.fieldDecl():\n            for field_ctx in ctx.fieldDecl():\n                field_ast = self.visit_fielddecl(field_ctx)\n                if field_ast:\n                    fields.append(field_ast)\n        \n        self.current_struct = None\n        \n        return {\n            \"type\": \"Struct\",\n            \"name\": name,\n            \"fields\": fields\n        }\n    \n    def visit_fielddecl(self, ctx):\n        \"\"\"Visit a field declaration in a struct.\"\"\"\n        name = self.visit(ctx.identifier())\n        field_type = self.visit(ctx.type_())\n        \n        # Check for default value\n        default_value = None\n        if hasattr(ctx, 'expression') and ctx.expression():\n            default_value = self.visit(ctx.expression())\n        \n        return {\n            \"type\": \"Field\",\n            \"name\": name,\n            \"field_type\": field_type,\n            \"default_value\": default_value\n        }\n    \n    def visit_enumdecl(self, ctx):\n        \"\"\"Visit an enum declaration.\"\"\"\n        name = self.visit(ctx.identifier())\n        variants = []\n        \n        # Process variants\n        if hasattr(ctx, 'enumVariant') and ctx.enumVariant():\n            for variant_ctx in ctx.enumVariant():\n                variant_ast = self.visit_enumvariant(variant_ctx)\n                if variant_ast:\n                    variants.append(variant_ast)\n        \n        return {\n            \"type\": \"Enum\",\n            \"name\": name,\n            \"variants\": variants\n        }\n    \n    def visit_enumvariant(self, ctx):\n        \"\"\"Visit an enum variant.\"\"\"\n        name = self.visit(ctx.identifier())\n        associated_types = []\n        \n        # Process associated types\n        if hasattr(ctx, 'type_') and ctx.type_():\n            for type_ctx in ctx.type_():\n                type_ast = self.visit(type_ctx)\n                if type_ast:\n                    associated_types.append(type_ast)\n        \n        return {\n            \"type\": \"EnumVariant\",\n            \"name\": name,\n            \"associated_types\": associated_types\n        }\n    \n    def visit_fndecl(self, ctx):\n        \"\"\"Visit a function declaration.\"\"\"\n        name = self.visit(ctx.identifier())\n        self.current_function = name\n        \n        # Process parameters\n        parameters = []\n        if hasattr(ctx, 'paramList') and ctx.paramList():\n            for param_ctx in ctx.paramList().parameter():\n                param_ast = self.visit_parameter(param_ctx)\n                if param_ast:\n                    parameters.append(param_ast)\n        \n        # Process return type\n        return_type = None\n        if hasattr(ctx, 'type_') and ctx.type_():\n            return_type = self.visit(ctx.type_())\n        \n        # Process function body\n        body = []\n        if hasattr(ctx, 'statement') and ctx.statement():\n            for stmt_ctx in ctx.statement():\n                stmt_ast = self.visit(stmt_ctx)\n                if stmt_ast:\n                    body.append(stmt_ast)\n        \n        self.current_function = None\n        \n        return {\n            \"type\": \"Function\",\n            \"name\": name,\n            \"parameters\": parameters,\n            \"return_type\": return_type,\n            \"body\": body\n        }\n    \n    def visit_parameter(self, ctx):\n        \"\"\"Visit a function parameter.\"\"\"\n        name = self.visit(ctx.identifier())\n        param_type = self.visit(ctx.type_())\n        \n        return {\n            \"type\": \"Parameter\",\n            \"name\": name,\n            \"parameter_type\": param_type\n        }\n    \n    def visit_identifier(self, ctx):\n        \"\"\"Visit an identifier and return its name.\"\"\"\n        return ctx.getText()\n    \n    # Type visitor methods\n    def visit_primitivetype(self, ctx):\n        \"\"\"Visit a primitive type node.\"\"\"\n        return ctx.PRIMITIVE_TYPE().getText()\n    \n    def visit_userdefinedtype(self, ctx):\n        \"\"\"Visit a user-defined type node.\"\"\"\n        return self.visit(ctx.identifier())\n    \n    def visit_optiontype(self, ctx):\n        \"\"\"Visit an Option<T> type node.\"\"\"\n        inner_type = self.visit(ctx.type_())\n        return {\n            \"type\": \"optionType\",\n            \"inner_type\": inner_type\n        }\n    \n    def visit_resulttype(self, ctx):\n        \"\"\"Visit a Result<T, E> type node.\"\"\"\n        value_type = self.visit(ctx.type_(0))\n        error_type = self.visit(ctx.type_(1))\n        return {\n            \"type\": \"resultType\",\n            \"value_type\": value_type,\n            \"error_type\": error_type\n        }\n    \n    def visit_arraytype(self, ctx):\n        \"\"\"Visit an array type node.\"\"\"\n        element_type = self.visit(ctx.type_())\n        return {\n            \"type\": \"arrayType\",\n            \"element_type\": element_type\n        }\n    \n    # Statement visitor methods\n    def visit_variabledecl(self, ctx):\n        \"\"\"Visit a variable declaration.\"\"\"\n        name = self.visit(ctx.identifier())\n        var_type = self.visit(ctx.type_())\n        \n        # Check for initialization\n        init_value = None\n        if hasattr(ctx, 'expression') and ctx.expression():\n            init_value = self.visit(ctx.expression())\n        \n        return {\n            \"type\": \"VariableDeclaration\",\n            \"name\": name,\n            \"var_type\": var_type,\n            \"init_value\": init_value\n        }\n    \n    def visit_returnstmt(self, ctx):\n        \"\"\"Visit a return statement.\"\"\"\n        value = None\n        if hasattr(ctx, 'expression') and ctx.expression():\n            value = self.visit(ctx.expression())\n        \n        return {\n            \"type\": \"ReturnStatement\",\n            \"value\": value\n        }\n    \n    # Additional visitor methods would be implemented as needed\n    \n    def visit_constructororfunctionexpr(self, ctx):\n        \"\"\"Visit a constructor or function call expression.\"\"\"\n        name = self.visit(ctx.identifier())\n        \n        # Process arguments\n        arguments = []\n        if hasattr(ctx, 'expressionList') and ctx.expressionList():\n            # Handle argument expressions\n            for expr in ctx.expressionList().expression():\n                arg = self.visit(expr)\n                if arg:\n                    arguments.append(arg)\n        \n        return {\n            \"type\": \"ConstructorOrFunctionCall\",\n            \"name\": name,\n            \"arguments\": arguments\n        }\n    \n    def visit_methodcallexpr(self, ctx):\n        \"\"\"Visit a method call expression.\"\"\"\n        target = self.visit(ctx.expression())\n        \n        # Process arguments\n        arguments = []\n        if hasattr(ctx, 'expressionList') and ctx.expressionList():\n            # Handle argument expressions\n            for expr in ctx.expressionList().expression():\n                arg = self.visit(expr)\n                if arg:\n                    arguments.append(arg)\n        \n        return {\n            \"type\": \"MethodCall\",\n            \"target\": target,\n            \"arguments\": arguments\n        }\n    \n    def visit_expressionstmt(self, ctx):\n        \"\"\"Visit an expression statement.\"\"\"\n        return {\n            \"type\": \"ExpressionStatement\",\n            \"expression\": self.visit(ctx.expression())\n        }\n\n\ndef test_parser():\n    \"\"\"Test function to verify the parser works.\"\"\"\n    parser = AegisParser()\n    test_code = \"\"\"\nmodule UserSystem:\n    struct User:\n        name: string\n        age: int\n    \n    fn get_user(name: string) -> User:\n        return User(name, 25)\n    \"\"\"\n    \n    try:\n        ast = parser.parse(test_code)\n        print(\"Parsing successful!\")\n        print(ast)\n        return True\n    except Exception as e:\n        print(f\"Parsing error: {e}\")\n        return False\n\n\nif __name__ == \"__main__\":\n    test_parser() ", "size": 19362, "lastModified": 1741351853.5089848, "moduleContext": "src/parser", "structure": {"classes": ["AegisParser", "AegisASTVisitor", "AegisErrorListener", "that"], "functions": ["visit_expressionstmt", "parse_file", "parse", "visit_variabledecl", "__init__", "visit_enumdecl", "visit_methodcallexpr", "visit_constructororfunctionexpr", "visit_optiontype", "visit_enumvariant", "visit", "visit_moduledecl", "visit_program", "visit_parameter", "visit_resulttype", "visit_structdecl", "visit_fndecl", "syntaxError", "visit_arraytype", "_get_suggestion", "visit_returnstmt", "visit_fallback", "visit_primitivetype", "visit_userdefinedtype", "visit_fielddecl", "test_parser", "visit_identifier"], "imports": ["sys", "InputStream", "Any", "AegisLangLexer", "lexer", "AegisIndentationLexer", "our", "AegisLangListener", "AegisLangParser", "antlr4", "os", "typing"]}, "stats": {"line_count": 561, "function_count": 27, "class_count": 4, "complexity_estimate": 145}, "contentHash": "4b958918d81e738d1a35bb2aeb4fd764"}
{"filePath": "src/codegen/llvm_generator.py", "language": "Python", "content": "\"\"\"\nAegis LLVM IR Code Generator\n\nThis module provides LLVM IR generation for the Aegis programming language.\nIt takes a validated AST and produces LLVM IR using llvmlite.\n\nThe generator follows Aegis's deterministic semantics and type safety principles,\noptimizing the IR for both JIT execution and AOT compilation.\n\"\"\"\n\nfrom llvmlite import ir, binding\nfrom typing import Dict, List, Any, Optional, Union, Tuple\nimport os\nimport logging\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n# Initialize LLVM\nbinding.initialize()\nbinding.initialize_native_target()\nbinding.initialize_native_asmprinter()\n\nclass LLVMGenerator:\n    \"\"\"\n    Generates LLVM IR from a validated Aegis AST.\n    \n    This generator expects a semantically valid AST that has passed type checking.\n    It handles all Aegis language constructs, including modules, structs, functions,\n    control flow, and expressions.\n    \n    Attributes:\n        ast: The validated AST to generate code from\n        module: The LLVM module being generated\n        builder: The IRBuilder for creating instructions\n        symbol_table: Maps Aegis symbols to their LLVM representations\n        current_function: The function currently being generated\n    \"\"\"\n    \n    def __init__(self, ast: Dict[str, Any], module_name: str = \"AegisModule\"):\n        \"\"\"\n        Initialize the LLVM generator with a validated AST.\n        \n        Args:\n            ast: The validated AST to generate code from\n            module_name: The name of the LLVM module to create\n        \"\"\"\n        logger.info(f\"Initializing LLVM generator for module: {module_name}\")\n        self.ast = ast\n        self.module = ir.Module(name=module_name)\n        self.builder = None  # Will be set when generating functions\n        self.symbol_table: Dict[str, Dict[str, Any]] = {}\n        self.current_function = None\n        self.return_values = {}  # For tracking return values in functions\n        \n        # Add target triple info for the current platform\n        # This can be overridden for cross-compilation\n        self.module.triple = binding.get_default_triple()\n        \n        # Initialize standard library declarations\n        self._declare_stdlib_functions()\n    \n    def _declare_stdlib_functions(self):\n        \"\"\"Declare external standard library functions that can be called from Aegis.\"\"\"\n        # Declare C printf for string output\n        printf_type = ir.FunctionType(\n            ir.IntType(32), [ir.PointerType(ir.IntType(8))], var_arg=True\n        )\n        printf_func = ir.Function(self.module, printf_type, name=\"printf\")\n        self.symbol_table[\"printf\"] = {\"value\": printf_func, \"type\": \"function\"}\n        \n        # TODO: Add more stdlib functions as needed\n    \n    def generate(self) -> str:\n        \"\"\"\n        Generate LLVM IR for the entire AST.\n        \n        Returns:\n            The generated LLVM IR as a string\n        \"\"\"\n        logger.info(\"Starting LLVM IR generation\")\n        \n        # First pass: declare all types and function signatures\n        self._declare_types_and_functions()\n        \n        # Second pass: implement function bodies\n        self._implement_functions()\n        \n        # Verify the module\n        try:\n            binding.parse_assembly(str(self.module))\n            logger.info(\"LLVM IR verification successful\")\n        except Exception as e:\n            logger.error(f\"LLVM IR verification failed: {e}\")\n            # Continue anyway, as we want to return the IR even if it has issues\n        \n        # Return the generated IR\n        ir_str = str(self.module)\n        logger.debug(f\"Generated LLVM IR:\\n{ir_str}\")\n        return ir_str\n    \n    def _declare_types_and_functions(self):\n        \"\"\"Declare all types (structs, enums) and function signatures.\"\"\"\n        logger.info(\"Declaring types and function signatures\")\n        \n        # Process top-level module declarations\n        if self.ast.get(\"node_type\") == \"module\":\n            self._process_module_declarations(self.ast)\n        else:\n            # Handle standalone declarations (not in a module)\n            for node in self.ast.get(\"children\", []):\n                self._declare_node(node)\n    \n    def _process_module_declarations(self, module_node):\n        \"\"\"Process declarations within a module.\"\"\"\n        module_name = module_node.get(\"name\", \"\")\n        logger.debug(f\"Processing declarations in module: {module_name}\")\n        \n        # Create a namespace for this module\n        if module_name not in self.symbol_table:\n            self.symbol_table[module_name] = {\"type\": \"module\", \"symbols\": {}}\n        \n        # Process all declarations in the module\n        for node in module_node.get(\"children\", []):\n            self._declare_node(node, module_name)\n    \n    def _declare_node(self, node, module_name=None):\n        \"\"\"Declare a node based on its type.\"\"\"\n        node_type = node.get(\"node_type\", \"\")\n        \n        if node_type == \"struct\":\n            self._declare_struct(node, module_name)\n        elif node_type == \"function\":\n            self._declare_function(node, module_name)\n        elif node_type == \"module\":\n            # Handle nested modules\n            self._process_module_declarations(node)\n    \n    def _declare_struct(self, struct_node, module_name=None):\n        \"\"\"\n        Declare a struct type in LLVM.\n        \n        Args:\n            struct_node: The AST node for the struct\n            module_name: Optional namespace for the struct\n        \"\"\"\n        struct_name = struct_node.get(\"name\", \"\")\n        qualified_name = f\"{module_name}.{struct_name}\" if module_name else struct_name\n        logger.debug(f\"Declaring struct: {qualified_name}\")\n        \n        # Extract field information\n        fields = []\n        field_types = []\n        \n        for field_node in struct_node.get(\"children\", []):\n            if field_node.get(\"node_type\") == \"field\":\n                field_name = field_node.get(\"name\", \"\")\n                field_type_str = field_node.get(\"field_type\", {}).get(\"name\", \"\")\n                \n                # Get the LLVM type for this field\n                field_type = self._get_llvm_type(field_type_str)\n                \n                fields.append((field_name, field_type))\n                field_types.append(field_type)\n        \n        # Create the LLVM struct type\n        struct_type = ir.LiteralStructType(field_types)\n        \n        # Register the struct in the symbol table\n        struct_entry = {\n            \"type\": \"struct\",\n            \"llvm_type\": struct_type,\n            \"fields\": fields,\n        }\n        \n        if module_name:\n            self.symbol_table[module_name][\"symbols\"][struct_name] = struct_entry\n        else:\n            self.symbol_table[struct_name] = struct_entry\n    \n    def _declare_function(self, function_node, module_name=None):\n        \"\"\"\n        Declare a function signature in LLVM.\n        \n        Args:\n            function_node: The AST node for the function\n            module_name: Optional namespace for the function\n        \"\"\"\n        function_name = function_node.get(\"name\", \"\")\n        qualified_name = f\"{module_name}.{function_name}\" if module_name else function_name\n        logger.debug(f\"Declaring function: {qualified_name}\")\n        \n        # Extract parameter information\n        params = []\n        llvm_param_types = []\n        \n        for param_node in function_node.get(\"parameters\", []):\n            param_name = param_node.get(\"name\", \"\")\n            param_type_str = param_node.get(\"param_type\", {}).get(\"name\", \"\")\n            \n            # Get the LLVM type for this parameter\n            param_type = self._get_llvm_type(param_type_str)\n            \n            params.append((param_name, param_type))\n            llvm_param_types.append(param_type)\n        \n        # Get the return type\n        return_type_node = function_node.get(\"return_type\", {})\n        return_type_str = return_type_node.get(\"name\", \"void\")\n        llvm_return_type = self._get_llvm_type(return_type_str)\n        \n        # Create the function type and declaration\n        function_type = ir.FunctionType(llvm_return_type, llvm_param_types)\n        function = ir.Function(self.module, function_type, name=qualified_name)\n        \n        # Name the parameters\n        for i, (param_name, _) in enumerate(params):\n            function.args[i].name = param_name\n        \n        # Register the function in the symbol table\n        function_entry = {\n            \"type\": \"function\",\n            \"value\": function,\n            \"llvm_type\": function_type,\n            \"return_type\": return_type_str,\n            \"params\": params,\n        }\n        \n        if module_name:\n            self.symbol_table[module_name][\"symbols\"][function_name] = function_entry\n        else:\n            self.symbol_table[function_name] = function_entry\n    \n    def _implement_functions(self):\n        \"\"\"Implement all function bodies.\"\"\"\n        logger.info(\"Implementing function bodies\")\n        \n        if self.ast.get(\"node_type\") == \"module\":\n            self._implement_module_functions(self.ast)\n        else:\n            # Handle standalone functions\n            for node in self.ast.get(\"children\", []):\n                if node.get(\"node_type\") == \"function\":\n                    self._implement_function(node)\n    \n    def _implement_module_functions(self, module_node):\n        \"\"\"Implement functions within a module.\"\"\"\n        module_name = module_node.get(\"name\", \"\")\n        \n        for node in module_node.get(\"children\", []):\n            if node.get(\"node_type\") == \"function\":\n                self._implement_function(node, module_name)\n            elif node.get(\"node_type\") == \"module\":\n                # Handle nested modules\n                self._implement_module_functions(node)\n    \n    def _implement_function(self, function_node, module_name=None):\n        \"\"\"\n        Implement a function body in LLVM.\n        \n        Args:\n            function_node: The AST node for the function\n            module_name: Optional namespace for the function\n        \"\"\"\n        function_name = function_node.get(\"name\", \"\")\n        qualified_name = f\"{module_name}.{function_name}\" if module_name else function_name\n        logger.debug(f\"Implementing function: {qualified_name}\")\n        \n        # Get the function from the symbol table\n        function_entry = self.symbol_table.get(qualified_name)\n        if not function_entry:\n            if module_name:\n                function_entry = self.symbol_table.get(module_name, {}).get(\"symbols\", {}).get(function_name)\n            \n            if not function_entry:\n                logger.error(f\"Function not found in symbol table: {qualified_name}\")\n                return\n        \n        function = function_entry[\"value\"]\n        self.current_function = function\n        \n        # Create the entry basic block\n        entry_block = function.append_basic_block(name=\"entry\")\n        self.builder = ir.IRBuilder(entry_block)\n        \n        # Create allocas for parameters at the start of the function\n        local_vars = {}\n        for i, (param_name, param_type) in enumerate(function_entry[\"params\"]):\n            param = function.args[i]\n            # Allocate stack space for the parameter\n            alloca = self.builder.alloca(param.type, name=param_name)\n            # Store the parameter value to the stack\n            self.builder.store(param, alloca)\n            # Track the variable in our local symbol table\n            local_vars[param_name] = {\"value\": alloca, \"type\": param_type}\n        \n        # Create a scope for local variables\n        function_scope = {\"local_vars\": local_vars, \"return_type\": function_entry[\"return_type\"]}\n        \n        # Generate code for the function body\n        body_nodes = function_node.get(\"body\", [])\n        \n        # Track if we've seen a return statement\n        has_return = False\n        \n        # Process each statement in the function body\n        for stmt_node in body_nodes:\n            result = self._generate_statement(stmt_node, function_scope)\n            if result and result.get(\"is_return\", False):\n                has_return = True\n        \n        # If no return statement was provided and return type is void, add one\n        if not has_return:\n            if function_entry[\"return_type\"] == \"void\":\n                self.builder.ret_void()\n            else:\n                # For non-void functions, provide a default return value based on type\n                default_value = self._get_default_value(function_entry[\"return_type\"])\n                self.builder.ret(default_value)\n        \n        # Clean up\n        self.current_function = None\n        self.builder = None\n    \n    def _generate_statement(self, stmt_node, scope):\n        \"\"\"\n        Generate code for a statement.\n        \n        Args:\n            stmt_node: The AST node for the statement\n            scope: The current scope information\n            \n        Returns:\n            A dict with information about the generated statement\n        \"\"\"\n        node_type = stmt_node.get(\"node_type\", \"\")\n        \n        if node_type == \"return_statement\":\n            return self._generate_return(stmt_node, scope)\n        elif node_type == \"variable_declaration\":\n            return self._generate_var_decl(stmt_node, scope)\n        elif node_type == \"if_statement\":\n            return self._generate_if(stmt_node, scope)\n        elif node_type == \"while_statement\":\n            return self._generate_while(stmt_node, scope)\n        elif node_type == \"for_statement\":\n            return self._generate_for(stmt_node, scope)\n        elif node_type == \"expression_statement\":\n            return self._generate_expression_stmt(stmt_node, scope)\n        else:\n            logger.warning(f\"Unknown statement type: {node_type}\")\n            return None\n    \n    def _generate_return(self, return_node, scope):\n        \"\"\"Generate code for a return statement.\"\"\"\n        logger.debug(\"Generating return statement\")\n        \n        # Check if there's a value to return\n        value_node = return_node.get(\"value\")\n        \n        if value_node:\n            # Generate code for the return value\n            value_info = self._generate_expression(value_node, scope)\n            if value_info:\n                # Add a return instruction\n                self.builder.ret(value_info[\"value\"])\n        else:\n            # No return value (void function)\n            self.builder.ret_void()\n        \n        return {\"is_return\": True}\n    \n    def _generate_var_decl(self, var_decl_node, scope):\n        \"\"\"Generate code for a variable declaration.\"\"\"\n        var_name = var_decl_node.get(\"name\", \"\")\n        var_type_str = var_decl_node.get(\"var_type\", {}).get(\"name\", \"\")\n        logger.debug(f\"Generating variable declaration: {var_name}: {var_type_str}\")\n        \n        # Get the LLVM type\n        var_type = self._get_llvm_type(var_type_str)\n        \n        # Allocate space for the variable\n        alloca = self.builder.alloca(var_type, name=var_name)\n        \n        # Initialize the variable if there's an initializer\n        init_node = var_decl_node.get(\"init_value\")\n        if init_node:\n            init_info = self._generate_expression(init_node, scope)\n            if init_info:\n                self.builder.store(init_info[\"value\"], alloca)\n        \n        # Add the variable to the current scope\n        scope[\"local_vars\"][var_name] = {\"value\": alloca, \"type\": var_type_str}\n        \n        return {\"var_name\": var_name, \"var_type\": var_type_str}\n    \n    def _generate_expression_stmt(self, expr_stmt_node, scope):\n        \"\"\"Generate code for an expression statement.\"\"\"\n        expr_node = expr_stmt_node.get(\"expression\")\n        if expr_node:\n            return self._generate_expression(expr_node, scope)\n        return None\n    \n    def _generate_expression(self, expr_node, scope):\n        \"\"\"\n        Generate code for an expression.\n        \n        Args:\n            expr_node: The AST node for the expression\n            scope: The current scope information\n            \n        Returns:\n            A dict with information about the generated expression\n        \"\"\"\n        node_type = expr_node.get(\"node_type\", \"\")\n        \n        if node_type == \"binary_operation\":\n            return self._generate_binary_op(expr_node, scope)\n        elif node_type == \"unary_operation\":\n            return self._generate_unary_op(expr_node, scope)\n        elif node_type == \"literal\":\n            return self._generate_literal(expr_node)\n        elif node_type == \"identifier\":\n            return self._generate_identifier(expr_node, scope)\n        elif node_type == \"function_call\":\n            return self._generate_function_call(expr_node, scope)\n        elif node_type == \"member_access\":\n            return self._generate_member_access(expr_node, scope)\n        else:\n            logger.warning(f\"Unknown expression type: {node_type}\")\n            return None\n    \n    def _generate_literal(self, literal_node):\n        \"\"\"Generate code for a literal value.\"\"\"\n        literal_type = literal_node.get(\"literal_type\", \"\")\n        value = literal_node.get(\"value\")\n        \n        if literal_type == \"int\":\n            return {\n                \"value\": ir.Constant(ir.IntType(64), value),\n                \"type\": \"int\",\n            }\n        elif literal_type == \"float\":\n            return {\n                \"value\": ir.Constant(ir.FloatType(), value),\n                \"type\": \"float\",\n            }\n        elif literal_type == \"bool\":\n            return {\n                \"value\": ir.Constant(ir.IntType(1), 1 if value else 0),\n                \"type\": \"bool\",\n            }\n        elif literal_type == \"string\":\n            # Create a global constant for the string (including null terminator)\n            string_data = bytearray(value, 'utf-8') + bytearray(1)\n            string_type = ir.ArrayType(ir.IntType(8), len(string_data))\n            global_string = ir.GlobalVariable(self.module, string_type, name=f\".str.{hash(value) & 0xFFFFFFFF}\")\n            global_string.global_constant = True\n            global_string.initializer = ir.Constant(string_type, string_data)\n            \n            # Get a pointer to the string\n            zero = ir.Constant(ir.IntType(32), 0)\n            string_ptr = self.builder.gep(global_string, [zero, zero], inbounds=True)\n            \n            return {\n                \"value\": string_ptr,\n                \"type\": \"string\",\n            }\n        else:\n            logger.warning(f\"Unknown literal type: {literal_type}\")\n            return None\n    \n    def _generate_identifier(self, identifier_node, scope):\n        \"\"\"Generate code for an identifier reference.\"\"\"\n        name = identifier_node.get(\"name\", \"\")\n        logger.debug(f\"Generating identifier reference: {name}\")\n        \n        # Check local variables first\n        local_vars = scope.get(\"local_vars\", {})\n        if name in local_vars:\n            var_info = local_vars[name]\n            # Load the value from the alloca\n            loaded_value = self.builder.load(var_info[\"value\"], name=f\"{name}.load\")\n            return {\n                \"value\": loaded_value,\n                \"type\": var_info[\"type\"],\n            }\n        \n        # Check global symbols\n        if name in self.symbol_table:\n            symbol = self.symbol_table[name]\n            if symbol[\"type\"] == \"function\":\n                return {\n                    \"value\": symbol[\"value\"],\n                    \"type\": \"function\",\n                }\n        \n        logger.error(f\"Undefined identifier: {name}\")\n        return None\n    \n    def _generate_function_call(self, call_node, scope):\n        \"\"\"Generate code for a function call.\"\"\"\n        function_name = call_node.get(\"name\", \"\")\n        logger.debug(f\"Generating function call: {function_name}\")\n        \n        # Get the function from the symbol table\n        function_entry = self.symbol_table.get(function_name)\n        if not function_entry:\n            logger.error(f\"Function not found: {function_name}\")\n            return None\n        \n        function = function_entry[\"value\"]\n        \n        # Generate code for arguments\n        arg_values = []\n        for arg_node in call_node.get(\"arguments\", []):\n            arg_info = self._generate_expression(arg_node, scope)\n            if arg_info:\n                arg_values.append(arg_info[\"value\"])\n        \n        # Call the function\n        call_result = self.builder.call(function, arg_values, name=f\"{function_name}.call\")\n        \n        return {\n            \"value\": call_result,\n            \"type\": function_entry[\"return_type\"],\n        }\n    \n    def _generate_binary_op(self, binary_op_node, scope):\n        \"\"\"Generate code for a binary operation.\"\"\"\n        operator = binary_op_node.get(\"operator\", \"\")\n        logger.debug(f\"Generating binary operation: {operator}\")\n        \n        # Generate code for left and right operands\n        left_info = self._generate_expression(binary_op_node.get(\"left\"), scope)\n        right_info = self._generate_expression(binary_op_node.get(\"right\"), scope)\n        \n        if not left_info or not right_info:\n            return None\n        \n        left_value = left_info[\"value\"]\n        right_value = right_info[\"value\"]\n        left_type = left_info[\"type\"]\n        \n        # Generate the appropriate instruction based on the operator and types\n        if left_type in [\"int\", \"bool\"]:\n            if operator == \"+\":\n                result = self.builder.add(left_value, right_value, name=\"add\")\n            elif operator == \"-\":\n                result = self.builder.sub(left_value, right_value, name=\"sub\")\n            elif operator == \"*\":\n                result = self.builder.mul(left_value, right_value, name=\"mul\")\n            elif operator == \"/\":\n                result = self.builder.sdiv(left_value, right_value, name=\"div\")\n            elif operator == \"%\":\n                result = self.builder.srem(left_value, right_value, name=\"mod\")\n            elif operator == \"<\":\n                result = self.builder.icmp_signed(\"<\", left_value, right_value, name=\"lt\")\n            elif operator == \"<=\":\n                result = self.builder.icmp_signed(\"<=\", left_value, right_value, name=\"le\")\n            elif operator == \">\":\n                result = self.builder.icmp_signed(\">\", left_value, right_value, name=\"gt\")\n            elif operator == \">=\":\n                result = self.builder.icmp_signed(\">=\", left_value, right_value, name=\"ge\")\n            elif operator == \"==\":\n                result = self.builder.icmp_signed(\"==\", left_value, right_value, name=\"eq\")\n            elif operator == \"!=\":\n                result = self.builder.icmp_signed(\"!=\", left_value, right_value, name=\"ne\")\n            elif operator == \"&&\":\n                result = self.builder.and_(left_value, right_value, name=\"and\")\n            elif operator == \"||\":\n                result = self.builder.or_(left_value, right_value, name=\"or\")\n            else:\n                logger.error(f\"Unknown integer operator: {operator}\")\n                return None\n        elif left_type == \"float\":\n            if operator == \"+\":\n                result = self.builder.fadd(left_value, right_value, name=\"add\")\n            elif operator == \"-\":\n                result = self.builder.fsub(left_value, right_value, name=\"sub\")\n            elif operator == \"*\":\n                result = self.builder.fmul(left_value, right_value, name=\"mul\")\n            elif operator == \"/\":\n                result = self.builder.fdiv(left_value, right_value, name=\"div\")\n            elif operator == \"<\":\n                result = self.builder.fcmp_ordered(\"<\", left_value, right_value, name=\"lt\")\n            elif operator == \"<=\":\n                result = self.builder.fcmp_ordered(\"<=\", left_value, right_value, name=\"le\")\n            elif operator == \">\":\n                result = self.builder.fcmp_ordered(\">\", left_value, right_value, name=\"gt\")\n            elif operator == \">=\":\n                result = self.builder.fcmp_ordered(\">=\", left_value, right_value, name=\"ge\")\n            elif operator == \"==\":\n                result = self.builder.fcmp_ordered(\"==\", left_value, right_value, name=\"eq\")\n            elif operator == \"!=\":\n                result = self.builder.fcmp_ordered(\"!=\", left_value, right_value, name=\"ne\")\n            else:\n                logger.error(f\"Unknown float operator: {operator}\")\n                return None\n        else:\n            logger.error(f\"Unsupported type for binary operation: {left_type}\")\n            return None\n        \n        # Determine the result type\n        if operator in [\"<\", \"<=\", \">\", \">=\", \"==\", \"!=\"]:\n            return {\n                \"value\": result,\n                \"type\": \"bool\",\n            }\n        else:\n            return {\n                \"value\": result,\n                \"type\": left_type,\n            }\n    \n    def _generate_unary_op(self, unary_op_node, scope):\n        \"\"\"Generate code for a unary operation.\"\"\"\n        operator = unary_op_node.get(\"operator\", \"\")\n        logger.debug(f\"Generating unary operation: {operator}\")\n        \n        # Generate code for the operand\n        operand_info = self._generate_expression(unary_op_node.get(\"operand\"), scope)\n        \n        if not operand_info:\n            return None\n        \n        operand_value = operand_info[\"value\"]\n        operand_type = operand_info[\"type\"]\n        \n        # Generate the appropriate instruction based on the operator and type\n        if operator == \"-\":\n            if operand_type == \"int\":\n                result = self.builder.neg(operand_value, name=\"neg\")\n            elif operand_type == \"float\":\n                result = self.builder.fneg(operand_value, name=\"fneg\")\n            else:\n                logger.error(f\"Unsupported type for negation: {operand_type}\")\n                return None\n        elif operator == \"!\":\n            if operand_type == \"bool\":\n                result = self.builder.not_(operand_value, name=\"not\")\n            else:\n                logger.error(f\"Unsupported type for logical not: {operand_type}\")\n                return None\n        else:\n            logger.error(f\"Unknown unary operator: {operator}\")\n            return None\n        \n        return {\n            \"value\": result,\n            \"type\": operand_type,\n        }\n    \n    def _get_llvm_type(self, aegis_type_str):\n        \"\"\"\n        Get the LLVM type corresponding to an Aegis type.\n        \n        Args:\n            aegis_type_str: The Aegis type name\n            \n        Returns:\n            The corresponding LLVM type\n        \"\"\"\n        if aegis_type_str == \"int\":\n            return ir.IntType(64)\n        elif aegis_type_str == \"float\":\n            return ir.FloatType()\n        elif aegis_type_str == \"bool\":\n            return ir.IntType(1)\n        elif aegis_type_str == \"string\":\n            return ir.PointerType(ir.IntType(8))\n        elif aegis_type_str == \"void\":\n            return ir.VoidType()\n        else:\n            # Check if it's a struct type\n            if aegis_type_str in self.symbol_table:\n                struct_entry = self.symbol_table[aegis_type_str]\n                if struct_entry[\"type\"] == \"struct\":\n                    return struct_entry[\"llvm_type\"]\n            \n            logger.warning(f\"Unknown type: {aegis_type_str}, defaulting to void\")\n            return ir.VoidType()\n    \n    def _get_default_value(self, aegis_type_str):\n        \"\"\"Get a default value for a given Aegis type.\"\"\"\n        if aegis_type_str == \"int\":\n            return ir.Constant(ir.IntType(64), 0)\n        elif aegis_type_str == \"float\":\n            return ir.Constant(ir.FloatType(), 0.0)\n        elif aegis_type_str == \"bool\":\n            return ir.Constant(ir.IntType(1), 0)\n        elif aegis_type_str == \"string\":\n            # Return empty string\n            string_data = bytearray(1)  # Just the null terminator\n            string_type = ir.ArrayType(ir.IntType(8), 1)\n            global_string = ir.GlobalVariable(self.module, string_type, name=f\".str.empty\")\n            global_string.global_constant = True\n            global_string.initializer = ir.Constant(string_type, string_data)\n            \n            # Get a pointer to the string\n            zero = ir.Constant(ir.IntType(32), 0)\n            return self.builder.gep(global_string, [zero, zero], inbounds=True)\n        else:\n            # For custom types, return null pointer\n            llvm_type = self._get_llvm_type(aegis_type_str)\n            if isinstance(llvm_type, ir.PointerType):\n                return ir.Constant(llvm_type, None)\n            else:\n                logger.warning(f\"No default value for type: {aegis_type_str}\")\n                return ir.Constant(ir.IntType(64), 0)\n\n# WebAssembly Support\nclass WasmGenerator(LLVMGenerator):\n    \"\"\"\n    Extends the LLVM Generator to produce WebAssembly-compatible IR.\n    \n    This class overrides key methods to ensure the generated IR complies\n    with WebAssembly's more limited type system and memory model.\n    \"\"\"\n    \n    def __init__(self, ast: Dict[str, Any], module_name: str = \"AegisWasmModule\"):\n        \"\"\"Initialize the WebAssembly generator.\"\"\"\n        super().__init__(ast, module_name)\n        \n        # Set the WebAssembly target triple\n        self.module.triple = \"wasm32-unknown-unknown\"\n    \n    def _get_llvm_type(self, aegis_type_str):\n        \"\"\"Get WebAssembly-compatible LLVM types.\"\"\"\n        if aegis_type_str == \"int\":\n            # WebAssembly prefers 32-bit integers\n            return ir.IntType(32)\n        else:\n            # Use the parent implementation for other types\n            return super()._get_llvm_type(aegis_type_str)\n    \n    def _declare_stdlib_functions(self):\n        \"\"\"Declare WebAssembly-compatible stdlib functions.\"\"\"\n        # In WebAssembly, we'd use imports for standard library functions\n        # This is a simplified example - actual WASM exports would need more configuration\n        \n        # Declare console_log for string output in WebAssembly\n        console_log_type = ir.FunctionType(\n            ir.VoidType(), [ir.PointerType(ir.IntType(8))]\n        )\n        console_log = ir.Function(self.module, console_log_type, name=\"console_log\")\n        self.symbol_table[\"console_log\"] = {\"value\": console_log, \"type\": \"function\"}\n\n# Example function showing how to generate LLVM IR for a function\ndef example_function_ir_generation():\n    \"\"\"Example of generating LLVM IR for a simple function.\"\"\"\n    module = ir.Module(name=\"example\")\n    \n    # Define a function that adds two integers\n    func_type = ir.FunctionType(ir.IntType(64), [ir.IntType(64), ir.IntType(64)])\n    func = ir.Function(module, func_type, name=\"add\")\n    \n    # Name the parameters\n    func.args[0].name = \"a\"\n    func.args[1].name = \"b\"\n    \n    # Create a basic block\n    block = func.append_basic_block(name=\"entry\")\n    builder = ir.IRBuilder(block)\n    \n    # Add the parameters\n    result = builder.add(func.args[0], func.args[1], name=\"result\")\n    \n    # Return the result\n    builder.ret(result)\n    \n    # Print the IR\n    print(str(module))\n    return str(module)\n\nif __name__ == \"__main__\":\n    # Example usage\n    print(\"LLVM IR example for a simple function:\")\n    print(example_function_ir_generation())", "size": 31374, "lastModified": 1741357342.645252, "moduleContext": "src/codegen", "structure": {"classes": ["LLVMGenerator", "WasmGenerator", "overrides"], "functions": ["_declare_types_and_functions", "__init__", "generate", "_process_module_declarations", "_get_llvm_type", "_implement_functions", "_declare_stdlib_functions", "_declare_function", "_generate_expression", "_implement_function", "_generate_expression_stmt", "_get_default_value", "_generate_statement", "example_function_ir_generation", "_generate_function_call", "_implement_module_functions", "_generate_literal", "_generate_return", "_generate_var_decl", "_generate_identifier", "_generate_binary_op", "_generate_unary_op", "_declare_struct", "_declare_node"], "imports": ["logging", "llvmlite", "module_name", "get_logger", "the", "Aegis", "Dict", "utils", "ir", "a", "os", "module", "typing"]}, "stats": {"line_count": 779, "function_count": 24, "class_count": 3, "complexity_estimate": 263}, "contentHash": "05d92df10e2b1e301f4bcf1634269067"}
{"filePath": "src/verification/z3_verifier.py", "language": "Python", "content": "", "size": 0, "lastModified": 1741346349.069334, "moduleContext": "src/verification", "structure": {"classes": [], "functions": [], "imports": []}, "stats": {"line_count": 1, "function_count": 0, "class_count": 0, "complexity_estimate": 0}, "contentHash": "d41d8cd98f00b204e9800998ecf8427e"}
{"filePath": "src/jit/jit_compiler.py", "language": "Python", "content": "import os\nimport ctypes\nfrom llvmlite import ir, binding\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n# -------------------------------\n# JIT Compiler\n# -------------------------------\n# init LLVM\nlogger.info(\"Initializing LLVM...\")\nbinding.initialize()\nbinding.initialize_native_target()\nbinding.initialize_native_asmprinter()\n\n# Load native library (assuming libaegis_stdimpl.dylib is in ./build)\nlib_path = os.path.join(\n    os.path.dirname(__file__), \"..\", \"build\", \"libaegis_stdimpl.dylib\"\n)\nif os.path.exists(lib_path):\n    binding.load_library_permanently(lib_path)\nelse:\n    raise FileNotFoundError(f\"Native library not found at {lib_path}\")\n\n\nclass JITCompiler:\n    \"\"\"Just-In-Time compiler for executing LLVM IR.\"\"\"\n    def __init__(self, llvm_ir):\n        \"\"\"Initialize with generated LLVM IR.\"\"\"\n        logger.info(\"Initializing JITCompiler...\")\n        self.llvm_ir = llvm_ir\n        self.target = binding.Target.from_default_triple()\n        self.target_machine = self.target.create_target_machine()\n        self.backing_mod = binding.parse_assembly(\"\")\n        self.engine = binding.create_mcjit_compiler(\n            self.backing_mod, self.target_machine\n        )\n\n    def compile_and_execute(self):\n        \"\"\"Compile and execute the LLVM IR.\"\"\"\n        logger.info(\"Compiling and executing LLVM IR...\")\n        try:\n            # Parse the IR\n            mod = binding.parse_assembly(self.llvm_ir)\n            mod.verify()\n            # Add the module and make sure it's ready for execution\n            self.engine.add_module(mod)\n            self.engine.finalize_object()\n\n            # Look up the main function if it exists\n            try:\n                main_func_ptr = self.engine.get_function_address(\"main\")\n                main_func = ctypes.CFUNCTYPE(ctypes.c_int)(main_func_ptr)\n                result = main_func()\n                return f\"Execution complete. Main function returned: {result}\"\n            except NameError:\n                # Find any function to execute as demo\n                for func in mod.functions:\n                    if not func.is_declaration:\n                        func_ptr = self.engine.get_function_address(func.name)\n                        # Get the return type and param types\n                        return_type = self._get_ctype_for_func_return(func)\n                        param_types = [\n                            self._get_ctype_for_type(param.type) for param in func.args\n                        ]\n                        # Create a callable function\n                        func_type = ctypes.CFUNCTYPE(return_type, *param_types)\n                        callable_func = func_type(func_ptr)\n                        # Execute with default values\n                        default_args = [\n                            self._get_default_value(param.type) for param in func.args\n                        ]\n                        result = callable_func(*default_args)\n                        logger.debug(f\"Executed function '{func.name}' with result: {result}\")\n                        return f\"Executed function '{func.name}' with result: {result}\"\n                    else:\n                        logger.warning(f\"Skipping declaration for function '{func.name}'\")\n                return \"No executable functions found in the module.\"\n\n        except Exception as e:\n            logger.error(f\"Error during compilation or execution: {str(e)}\")\n            return f\"Error during compilation or execution: {str(e)}\"\n\n    def _get_ctype_for_type(self, llvm_type):\n        \"\"\"Map LLVM types to ctypes types.\"\"\"\n        logger.info(\"Getting ctypes type...\")\n        if llvm_type.is_integer():\n            if llvm_type.width <= 8:\n                return ctypes.c_uint8\n            elif llvm_type.width <= 16:\n                return ctypes.c_uint16\n            elif llvm_type.width <= 32:\n                return ctypes.c_uint32\n            else:\n                return ctypes.c_uint64\n        elif llvm_type.is_float():\n            return ctypes.c_float\n        elif llvm_type.is_double():\n            return ctypes.c_double\n        elif llvm_type.is_pointer():\n            return ctypes.c_void_p\n        else:\n            # Default to void pointer for complex types\n            logger.warning(\"Defaulting to void pointer for complex types\")\n            return ctypes.c_void_p\n\n    def _get_ctype_for_func_return(self, func):\n        \"\"\"Get the ctypes return type for a function.\"\"\"\n        logger.info(\"Getting ctypes return type...\")\n        return_type = func.return_type\n        if str(return_type) == \"void\":\n            return None\n        logger.debug(f\"Ctypes return type: {self._get_ctype_for_type(return_type)}\")\n        return self._get_ctype_for_type(return_type)\n\n    def _get_default_value(self, llvm_type):\n        \"\"\"Get a default value for a given LLVM type.\"\"\"\n        logger.info(\"Getting default value...\")\n        if llvm_type.is_integer():\n            logger.debug(\"Defaulting to 0 for integer\")\n            return 0\n        elif llvm_type.is_float() or llvm_type.is_double():\n            logger.debug(\"Defaulting to 0.0 for float or double\")\n            return 0.0\n        elif llvm_type.is_pointer():\n            logger.warning(\"Defaulting to None for pointer types\")\n            return None\n        else:\n            logger.warning(\"Defaulting to None for complex types\")\n            return None\n", "size": 5408, "lastModified": 1741346218.5082676, "moduleContext": "src/jit", "structure": {"classes": ["JITCompiler"], "functions": ["_get_ctype_for_type", "_get_ctype_for_func_return", "__init__", "compile_and_execute", "_get_default_value"], "imports": ["llvmlite", "ctypes", "get_logger", "utils", "ir", "os"]}, "stats": {"line_count": 131, "function_count": 5, "class_count": 1, "complexity_estimate": 61}, "contentHash": "ccb69e330621f50a81ee03125eaa190a"}
{"filePath": "src/semantic/type_checker.py", "language": "Python", "content": "from typing import Dict, List, Any, Optional, Union, Set\nfrom dataclasses import dataclass\nfrom src.parser.aeigix_ast_visitor import SourcePosition\nfrom src.semantic.symbol_table import SymbolTable, Symbol, SymbolType, Scope\nimport logging\n\nlogger = logging.getLogger(__name__)\n\n@dataclass\nclass TypeCheckError:\n    \"\"\"Represents a type checking error with a helpful message and suggestion.\"\"\"\n    message: str\n    suggestion: str\n    position: SourcePosition\n    \n    def __str__(self) -> str:\n        return f\"{self.position}: Error: {self.message}\\nSuggestion: {self.suggestion}\"\n\nclass TypeChecker:\n    \"\"\"\n    Type checker for Aegis programming language.\n    \n    Performs semantic analysis to ensure type safety, verify all symbols are defined,\n    and confirm that functions with non-void return types return values on all code paths.\n    \n    Provides detailed, AI-friendly error messages with suggestions for fixing issues.\n    \"\"\"\n    \n    def __init__(self):\n        self.symbol_table = SymbolTable()\n        self.errors = []\n        self.current_function = None\n        self.current_function_returns = False\n        self.in_loop = False\n    \n    def check(self, ast: Dict[str, Any]) -> List[TypeCheckError]:\n        \"\"\"\n        Perform type checking on the entire AST.\n        \n        Args:\n            ast: The AST to check\n            \n        Returns:\n            List of type checking errors\n        \"\"\"\n        logger.info(\"Starting type checking\")\n        \n        # Clear any previous state\n        self.symbol_table = SymbolTable()\n        self.errors = []\n        \n        # First pass: register all top-level declarations\n        self._register_declarations(ast)\n        \n        # Second pass: validate all declarations and check for type errors\n        self._check_node(ast)\n        \n        if not self.errors:\n            logger.info(\"Type checking completed successfully\")\n        else:\n            logger.error(f\"Type checking failed with {len(self.errors)} errors\")\n            \n        return self.errors\n    \n    def _register_declarations(self, node: Dict[str, Any]) -> None:\n        \"\"\"\n        First pass to register all declarations in the symbol table.\n        \n        This establishes all available types, functions, and variables before\n        checking their implementations, which helps with forward references.\n        \n        Args:\n            node: The AST node to process\n        \"\"\"\n        if node is None:\n            return\n            \n        node_type = node.get(\"node_type\", \"\")\n        \n        if node_type == \"module\":\n            # Register the module and process its children\n            module_name = node[\"name\"]\n            self.symbol_table.enter_scope(module_name)\n            \n            for child in node.get(\"children\", []):\n                self._register_declarations(child)\n                \n            self.symbol_table.exit_scope()\n            \n        elif node_type == \"struct\":\n            # Register the struct type\n            struct_name = node[\"name\"]\n            fields = {}\n            \n            for field in node.get(\"fields\", []):\n                field_name = field[\"name\"]\n                field_type = field[\"type_annotation\"][\"name\"]\n                fields[field_name] = field_type\n                \n            self.symbol_table.add_symbol(\n                name=struct_name,\n                symbol_type=SymbolType.TYPE,\n                type_info={\n                    \"kind\": \"struct\",\n                    \"fields\": fields\n                }\n            )\n            \n            # Process method declarations\n            for method in node.get(\"methods\", []):\n                self._register_declarations(method)\n                \n        elif node_type == \"enum\":\n            # Register the enum type\n            enum_name = node[\"name\"]\n            variants = {}\n            \n            for variant in node.get(\"variants\", []):\n                variant_name = variant[\"name\"]\n                variant_fields = {}\n                \n                for field in variant.get(\"fields\", []):\n                    field_name = field[\"name\"] if \"name\" in field else \"\"\n                    field_type = field[\"type_annotation\"][\"name\"]\n                    variant_fields[field_name] = field_type\n                \n                variants[variant_name] = variant_fields\n                \n            self.symbol_table.add_symbol(\n                name=enum_name,\n                symbol_type=SymbolType.TYPE,\n                type_info={\n                    \"kind\": \"enum\",\n                    \"variants\": variants\n                }\n            )\n            \n            # Process method declarations\n            for method in node.get(\"methods\", []):\n                self._register_declarations(method)\n                \n        elif node_type == \"function\":\n            # Register the function signature\n            func_name = node[\"name\"]\n            params = []\n            \n            for param in node.get(\"params\", []):\n                param_name = param[\"name\"]\n                param_type = param[\"type_annotation\"][\"name\"] if param.get(\"type_annotation\") else \"any\"\n                params.append((param_name, param_type))\n                \n            return_type = node.get(\"return_type\", {}).get(\"name\", \"void\")\n            \n            self.symbol_table.add_symbol(\n                name=func_name,\n                symbol_type=SymbolType.FUNCTION,\n                type_info={\n                    \"params\": params,\n                    \"return_type\": return_type,\n                    \"is_async\": node.get(\"is_async\", False)\n                }\n            )\n            \n        elif node_type == \"trait\":\n            # Register the trait\n            trait_name = node[\"name\"]\n            methods = {}\n            \n            for method in node.get(\"methods\", []):\n                method_name = method[\"name\"]\n                params = []\n                \n                for param in method.get(\"params\", []):\n                    param_name = param[\"name\"]\n                    param_type = param[\"type_annotation\"][\"name\"] if param.get(\"type_annotation\") else \"any\"\n                    params.append((param_name, param_type))\n                    \n                return_type = method.get(\"return_type\", {}).get(\"name\", \"void\")\n                \n                methods[method_name] = {\n                    \"params\": params,\n                    \"return_type\": return_type,\n                    \"is_async\": method.get(\"is_async\", False)\n                }\n                \n            self.symbol_table.add_symbol(\n                name=trait_name,\n                symbol_type=SymbolType.TRAIT,\n                type_info={\n                    \"methods\": methods\n                }\n            )\n    \n    def _check_node(self, node: Dict[str, Any]) -> Optional[str]:\n        \"\"\"\n        Check a node for type errors and validate its children.\n        \n        Args:\n            node: The AST node to check\n            \n        Returns:\n            The type of the expression, if applicable\n        \"\"\"\n        if node is None:\n            return None\n            \n        node_type = node.get(\"node_type\", \"\")\n        position = node.get(\"position\", SourcePosition(0, 0, \"\"))\n        \n        # Handle each node type\n        if node_type == \"module\":\n            module_name = node[\"name\"]\n            self.symbol_table.enter_scope(module_name)\n            \n            for child in node.get(\"children\", []):\n                self._check_node(child)\n                \n            self.symbol_table.exit_scope()\n            \n        elif node_type == \"struct\":\n            struct_name = node[\"name\"]\n            self.symbol_table.enter_scope(struct_name)\n            \n            # Check field types exist\n            for field in node.get(\"fields\", []):\n                field_type_name = field[\"type_annotation\"][\"name\"]\n                if not self._is_valid_type(field_type_name):\n                    self.errors.append(TypeCheckError(\n                        message=f\"Field '{field['name']}' has undefined type '{field_type_name}'\",\n                        suggestion=f\"Use a valid type like 'int', 'string', or define the struct '{field_type_name}' before using it\",\n                        position=field[\"position\"]\n                    ))\n            \n            # Check methods\n            for method in node.get(\"methods\", []):\n                self._check_node(method)\n                \n            self.symbol_table.exit_scope()\n            \n        elif node_type == \"enum\":\n            enum_name = node[\"name\"]\n            self.symbol_table.enter_scope(enum_name)\n            \n            # Check variant field types exist\n            for variant in node.get(\"variants\", []):\n                for field in variant.get(\"fields\", []):\n                    field_type_name = field[\"type_annotation\"][\"name\"]\n                    if not self._is_valid_type(field_type_name):\n                        self.errors.append(TypeCheckError(\n                            message=f\"Variant field '{field['name']}' has undefined type '{field_type_name}'\",\n                            suggestion=f\"Use a valid type like 'int', 'string', or define the type '{field_type_name}' before using it\",\n                            position=field[\"position\"]\n                        ))\n            \n            # Check methods\n            for method in node.get(\"methods\", []):\n                self._check_node(method)\n                \n            self.symbol_table.exit_scope()\n            \n        elif node_type == \"function\":\n            func_name = node[\"name\"]\n            self.current_function = node\n            self.current_function_returns = False\n            \n            # Check return type exists\n            return_type = node.get(\"return_type\", {}).get(\"name\", \"void\")\n            if return_type != \"void\" and not self._is_valid_type(return_type):\n                self.errors.append(TypeCheckError(\n                    message=f\"Function '{func_name}' has undefined return type '{return_type}'\",\n                    suggestion=f\"Use a valid type like 'int', 'string', or define the type '{return_type}' before using it\",\n                    position=node[\"position\"]\n                ))\n            \n            # Enter function scope\n            self.symbol_table.enter_scope(func_name)\n            \n            # Add parameters to scope\n            for param in node.get(\"params\", []):\n                param_name = param[\"name\"]\n                param_type = param[\"type_annotation\"][\"name\"] if param.get(\"type_annotation\") else \"any\"\n                \n                # Check parameter type exists\n                if not self._is_valid_type(param_type):\n                    self.errors.append(TypeCheckError(\n                        message=f\"Parameter '{param_name}' has undefined type '{param_type}'\",\n                        suggestion=f\"Use a valid type like 'int', 'string', or define the type '{param_type}' before using it\",\n                        position=param[\"position\"]\n                    ))\n                \n                self.symbol_table.add_symbol(\n                    name=param_name,\n                    symbol_type=SymbolType.VARIABLE,\n                    type_info=param_type\n                )\n            \n            # Check function body\n            for stmt in node.get(\"body\", []):\n                self._check_node(stmt)\n            \n            # Check if function returns a value on all paths if non-void\n            if return_type != \"void\" and not self.current_function_returns:\n                self.errors.append(TypeCheckError(\n                    message=f\"Function '{func_name}' must return a value of type '{return_type}' on all code paths\",\n                    suggestion=\"Add a return statement with the appropriate value type at the end of the function\",\n                    position=node[\"position\"]\n                ))\n            \n            self.symbol_table.exit_scope()\n            self.current_function = None\n            \n        elif node_type == \"var_declaration\":\n            var_name = node[\"name\"]\n            var_type = node[\"type_annotation\"][\"name\"] if node.get(\"type_annotation\") else None\n            \n            # Check if the variable type exists\n            if var_type and not self._is_valid_type(var_type):\n                self.errors.append(TypeCheckError(\n                    message=f\"Variable '{var_name}' has undefined type '{var_type}'\",\n                    suggestion=f\"Use a valid type like 'int', 'string', or define the type '{var_type}' before using it\",\n                    position=node[\"position\"]\n                ))\n            \n            # Check initialization value type\n            init_value = node.get(\"init_value\")\n            if init_value:\n                init_type = self._check_node(init_value)\n                \n                if var_type and init_type and not self._are_types_compatible(var_type, init_type):\n                    self.errors.append(TypeCheckError(\n                        message=f\"Cannot assign value of type '{init_type}' to variable '{var_name}' of type '{var_type}'\",\n                        suggestion=f\"Use a value of type '{var_type}' or convert the value to '{var_type}'\",\n                        position=node[\"position\"]\n                    ))\n                \n                # Infer type if not specified\n                if not var_type and init_type:\n                    var_type = init_type\n            \n            # Add variable to symbol table\n            self.symbol_table.add_symbol(\n                name=var_name,\n                symbol_type=SymbolType.VARIABLE,\n                type_info=var_type or \"any\"\n            )\n            \n            return var_type\n            \n        elif node_type == \"assignment\":\n            target = node[\"target\"]\n            target_type = self._check_node(target)\n            \n            value = node[\"value\"]\n            value_type = self._check_node(value)\n            \n            # Check if types are compatible\n            if target_type and value_type and not self._are_types_compatible(target_type, value_type):\n                target_name = target.get(\"name\", \"expression\")\n                self.errors.append(TypeCheckError(\n                    message=f\"Cannot assign value of type '{value_type}' to target of type '{target_type}'\",\n                    suggestion=f\"Use a value of type '{target_type}' or convert the value to '{target_type}'\",\n                    position=node[\"position\"]\n                ))\n            \n            # Check if target is immutable (let)\n            if target.get(\"node_type\") == \"identifier\":\n                symbol = self.symbol_table.lookup(target[\"name\"])\n                if symbol and hasattr(symbol, \"is_mutable\") and not symbol.is_mutable:\n                    self.errors.append(TypeCheckError(\n                        message=f\"Cannot assign to immutable variable '{target['name']}'\",\n                        suggestion=\"Use 'var' instead of 'let' if the variable needs to be mutable\",\n                        position=node[\"position\"]\n                    ))\n            \n            return target_type\n            \n        elif node_type == \"binary_op\":\n            left_type = self._check_node(node[\"left\"])\n            right_type = self._check_node(node[\"right\"])\n            operator = node[\"operator\"]\n            \n            # Check operator compatibility\n            result_type = self._check_binary_op_types(left_type, right_type, operator, node[\"position\"])\n            return result_type\n            \n        elif node_type == \"unary_op\":\n            operand_type = self._check_node(node[\"operand\"])\n            operator = node[\"operator\"]\n            \n            # Check operator compatibility\n            result_type = self._check_unary_op_types(operand_type, operator, node[\"position\"])\n            return result_type\n            \n        elif node_type == \"call\":\n            callee = node[\"callee\"]\n            callee_type = self._check_node(callee)\n            \n            # Handle method calls and function calls differently\n            if callee.get(\"node_type\") == \"member_access\":\n                return self._check_method_call(callee, node.get(\"args\", []), node[\"position\"])\n            else:\n                return self._check_function_call(callee[\"name\"] if \"name\" in callee else \"\", node.get(\"args\", []), node[\"position\"])\n            \n        elif node_type == \"if_statement\":\n            # Check condition is boolean\n            condition_type = self._check_node(node[\"condition\"])\n            if condition_type and condition_type != \"bool\":\n                self.errors.append(TypeCheckError(\n                    message=f\"If condition must be a boolean, got '{condition_type}'\",\n                    suggestion=\"Use a comparison or logical expression that evaluates to a boolean\",\n                    position=node[\"position\"]\n                ))\n            \n            # Check branches\n            self.symbol_table.enter_scope(\"if_branch\")\n            self._check_node(node[\"then_block\"])\n            self.symbol_table.exit_scope()\n            \n            if node.get(\"else_block\"):\n                self.symbol_table.enter_scope(\"else_branch\")\n                self._check_node(node[\"else_block\"])\n                self.symbol_table.exit_scope()\n            \n            # Check elif branches\n            for branch in node.get(\"elif_branches\", []):\n                elif_condition_type = self._check_node(branch[\"condition\"])\n                if elif_condition_type and elif_condition_type != \"bool\":\n                    self.errors.append(TypeCheckError(\n                        message=f\"Elif condition must be a boolean, got '{elif_condition_type}'\",\n                        suggestion=\"Use a comparison or logical expression that evaluates to a boolean\",\n                        position=branch[\"condition\"][\"position\"]\n                    ))\n                \n                self.symbol_table.enter_scope(\"elif_branch\")\n                self._check_node(branch[\"block\"])\n                self.symbol_table.exit_scope()\n            \n        elif node_type == \"for_loop\":\n            self.in_loop = True\n            \n            # Check iterable is actually iterable\n            iterable_type = self._check_node(node[\"iterable\"])\n            element_type = self._get_element_type(iterable_type)\n            \n            if not element_type:\n                self.errors.append(TypeCheckError(\n                    message=f\"Cannot iterate over type '{iterable_type}'\",\n                    suggestion=\"Use a collection type like an array, range, or implement the Iterable trait\",\n                    position=node[\"iterable\"][\"position\"]\n                ))\n            \n            # Set up loop variable in new scope\n            self.symbol_table.enter_scope(\"for_loop\")\n            iterator_name = node[\"iterator\"][\"name\"] if node[\"iterator\"].get(\"node_type\") == \"var_declaration\" else node[\"iterator\"][\"name\"]\n            \n            self.symbol_table.add_symbol(\n                name=iterator_name,\n                symbol_type=SymbolType.VARIABLE,\n                type_info=element_type or \"any\"\n            )\n            \n            # Check loop body\n            self._check_node(node[\"body\"])\n            \n            self.symbol_table.exit_scope()\n            self.in_loop = False\n            \n        elif node_type == \"while_loop\":\n            self.in_loop = True\n            \n            # Check condition is boolean\n            condition_type = self._check_node(node[\"condition\"])\n            if condition_type and condition_type != \"bool\":\n                self.errors.append(TypeCheckError(\n                    message=f\"While condition must be a boolean, got '{condition_type}'\",\n                    suggestion=\"Use a comparison or logical expression that evaluates to a boolean\",\n                    position=node[\"condition\"][\"position\"]\n                ))\n            \n            # Check loop body\n            self.symbol_table.enter_scope(\"while_loop\")\n            self._check_node(node[\"body\"])\n            self.symbol_table.exit_scope()\n            \n            self.in_loop = False\n            \n        elif node_type == \"return_statement\":\n            # Mark that this function has a return statement\n            self.current_function_returns = True\n            \n            # Check return type matches function return type\n            if self.current_function:\n                expected_type = self.current_function.get(\"return_type\", {}).get(\"name\", \"void\")\n                \n                if expected_type == \"void\" and node.get(\"value\"):\n                    self.errors.append(TypeCheckError(\n                        message=\"Cannot return a value from a function with void return type\",\n                        suggestion=\"Remove the return value or change the function return type\",\n                        position=node[\"position\"]\n                    ))\n                elif expected_type != \"void\":\n                    if not node.get(\"value\"):\n                        self.errors.append(TypeCheckError(\n                            message=f\"Function expects return value of type '{expected_type}' but no value is returned\",\n                            suggestion=f\"Add a return value of type '{expected_type}'\",\n                            position=node[\"position\"]\n                        ))\n                    else:\n                        actual_type = self._check_node(node[\"value\"])\n                        if actual_type and not self._are_types_compatible(expected_type, actual_type):\n                            self.errors.append(TypeCheckError(\n                                message=f\"Function expects return type '{expected_type}' but got '{actual_type}'\",\n                                suggestion=f\"Return a value of type '{expected_type}' or convert the current value\",\n                                position=node[\"value\"][\"position\"]\n                            ))\n            \n        elif node_type == \"block\":\n            self.symbol_table.enter_scope(\"block\")\n            \n            for stmt in node.get(\"statements\", []):\n                self._check_node(stmt)\n                \n            self.symbol_table.exit_scope()\n            \n        elif node_type == \"identifier\":\n            name = node[\"name\"]\n            symbol = self.symbol_table.lookup(name)\n            \n            if not symbol:\n                self.errors.append(TypeCheckError(\n                    message=f\"Undefined symbol '{name}'\",\n                    suggestion=f\"Declare the variable before using it or check for typos\",\n                    position=node[\"position\"]\n                ))\n                return None\n                \n            if symbol.symbol_type == SymbolType.VARIABLE:\n                return symbol.type_info\n            elif symbol.symbol_type == SymbolType.FUNCTION:\n                return \"function\"\n            elif symbol.symbol_type == SymbolType.TYPE:\n                return \"type\"\n            \n            return None\n            \n        elif node_type == \"member_access\":\n            object_type = self._check_node(node[\"object\"])\n            member_name = node[\"member\"]\n            \n            # Get the field type from the struct or enum\n            field_type = self._get_member_type(object_type, member_name, node[\"position\"])\n            return field_type\n            \n        elif node_type == \"literal\":\n            literal_type = node.get(\"literal_type\", \"\")\n            \n            if literal_type == \"int\":\n                return \"int\"\n            elif literal_type == \"float\":\n                return \"float\"\n            elif literal_type == \"bool\":\n                return \"bool\"\n            elif literal_type == \"string\":\n                return \"string\"\n            else:\n                return None\n                \n        elif node_type == \"match_statement\":\n            subject_type = self._check_node(node[\"subject\"])\n            \n            # Check each branch\n            for branch in node.get(\"branches\", []):\n                self.symbol_table.enter_scope(\"match_branch\")\n                \n                # Check pattern compatibility with subject\n                pattern = branch[\"pattern\"]\n                if pattern.get(\"node_type\") == \"identifier\":\n                    # Binding pattern - adds variable to scope\n                    self.symbol_table.add_symbol(\n                        name=pattern[\"name\"],\n                        symbol_type=SymbolType.VARIABLE,\n                        type_info=subject_type or \"any\"\n                    )\n                elif subject_type:\n                    # Check if pattern is compatible with subject type\n                    self._check_match_pattern(subject_type, pattern)\n                \n                # Check guard condition\n                if branch.get(\"guard\"):\n                    guard_type = self._check_node(branch[\"guard\"])\n                    if guard_type and guard_type != \"bool\":\n                        self.errors.append(TypeCheckError(\n                            message=f\"Match guard must be a boolean, got '{guard_type}'\",\n                            suggestion=\"Use a comparison or logical expression that evaluates to a boolean\",\n                            position=branch[\"guard\"][\"position\"]\n                        ))\n                \n                # Check branch body\n                self._check_node(branch[\"body\"])\n                \n                self.symbol_table.exit_scope()\n                \n        elif node_type == \"await_expression\":\n            expression_type = self._check_node(node[\"expression\"])\n            \n            # Check if we're in an async function\n            if self.current_function and not self.current_function.get(\"is_async\", False):\n                self.errors.append(TypeCheckError(\n                    message=\"Cannot use 'await' outside of an async function\",\n                    suggestion=\"Mark the enclosing function as async using the 'async' keyword\",\n                    position=node[\"position\"]\n                ))\n            \n            # Check if expression is awaitable\n            awaitable_type = self._get_awaitable_type(expression_type, node[\"position\"])\n            return awaitable_type\n            \n        elif node_type == \"task_spawn\":\n            # Check task body\n            self.symbol_table.enter_scope(\"task\")\n            body_type = self._check_node(node[\"body\"])\n            self.symbol_table.exit_scope()\n            \n            # Task types always wrap their result type\n            return f\"Task<{body_type or 'void'}>\"\n        \n        return None\n    \n    def _is_valid_type(self, type_name: str) -> bool:\n        \"\"\"Check if a type name refers to a valid type.\"\"\"\n        # Primitive types\n        if type_name in [\"int\", \"float\", \"bool\", \"string\", \"void\", \"any\"]:\n            return True\n            \n        # Check user-defined types\n        symbol = self.symbol_table.lookup(type_name)\n        return symbol is not None and symbol.symbol_type == SymbolType.TYPE\n    \n    def _are_types_compatible(self, target_type: str, source_type: str) -> bool:\n        \"\"\"Check if source_type can be assigned to target_type.\"\"\"\n        # Same types are always compatible\n        if target_type == source_type:\n            return True\n            \n        # Any can be assigned to any type (dynamic escape hatch)\n        if source_type == \"any\" or target_type == \"any\":\n            return True\n            \n        # Numeric conversions with potential precision loss are not allowed\n        # (would require explicit casts)\n        if target_type == \"int\" and source_type == \"float\":\n            return False\n            \n        # Float can accept int (widening conversion)\n        if target_type == \"float\" and source_type == \"int\":\n            return True\n            \n        # Generic type compatibility\n        if \"<\" in target_type and \"<\" in source_type:\n            # Extract the base types and type parameters\n            target_base = target_type.split(\"<\")[0]\n            source_base = source_type.split(\"<\")[0]\n            \n            if target_base != source_base:\n                return False\n                \n            # Extract and check type parameters\n            target_params = target_type[target_type.index(\"<\")+1:target_type.rindex(\">\")].split(\",\")\n            source_params = source_type[source_type.index(\"<\")+1:source_type.rindex(\">\")].split(\",\")\n            \n            if len(target_params) != len(source_params):\n                return False\n                \n            for i in range(len(target_params)):\n                if not self._are_types_compatible(target_params[i].strip(), source_params[i].strip()):\n                    return False\n                    \n            return True\n            \n        # For user-defined types, check hierarchy (would need trait/impl info)\n        # Placeholder for future trait/inheritance compatibility\n        \n        return False\n    \n    def _check_binary_op_types(self, left_type: str, right_type: str, operator: str, position: SourcePosition) -> Optional[str]:\n        \"\"\"Check if the binary operator can be applied to the given types.\"\"\"\n        # Handle arithmetic operators\n        if operator in [\"+\", \"-\", \"*\", \"/\", \"%\"]:\n            if left_type in [\"int\", \"float\"] and right_type in [\"int\", \"float\"]:\n                # For mixed numeric operations, result is widest type\n                if left_type == \"float\" or right_type == \"float\":\n                    return \"float\"\n                else:\n                    return \"int\"\n            elif operator == \"+\" and left_type == \"string\" and right_type == \"string\":\n                # String concatenation\n                return \"string\"\n            else:\n                self.errors.append(TypeCheckError(\n                    message=f\"Operator '{operator}' cannot be applied to types '{left_type}' and '{right_type}'\",\n                    suggestion=f\"Use numeric types for arithmetic operations or strings for concatenation (+)\",\n                    position=position\n                ))\n                return None\n                \n        # Handle comparison operators\n        elif operator in [\"==\", \"!=\", \"<\", \">\", \"<=\", \">=\"]:\n            if left_type is None or right_type is None:\n                return None\n                \n            if left_type == right_type:\n                # Same types can always be compared for equality\n                return \"bool\"\n            elif left_type in [\"int\", \"float\"] and right_type in [\"int\", \"float\"]:\n                # Mixed numeric comparisons are valid\n                return \"bool\"\n            else:\n                if operator in [\"==\", \"!=\"]:\n                    # Only allow equality checks if types are compatible\n                    if self._are_types_compatible(left_type, right_type) or self._are_types_compatible(right_type, left_type):\n                        return \"bool\"\n                        \n                self.errors.append(TypeCheckError(\n                    message=f\"Cannot compare values of types '{left_type}' and '{right_type}' with operator '{operator}'\",\n                    suggestion=\"Use comparable types or implement comparison operators for custom types\",\n                    position=position\n                ))\n                return None\n                \n        # Handle logical operators\n        elif operator in [\"&&\", \"||\"]:\n            if left_type == \"bool\" and right_type == \"bool\":\n                return \"bool\"\n            else:\n                self.errors.append(TypeCheckError(\n                    message=f\"Logical operator '{operator}' requires boolean operands, got '{left_type}' and '{right_type}'\",\n                    suggestion=\"Use boolean expressions for logical operations\",\n                    position=position\n                ))\n                return None\n        \n        return None\n    \n    def _check_unary_op_types(self, operand_type: str, operator: str, position: SourcePosition) -> Optional[str]:\n        \"\"\"Check if the unary operator can be applied to the given type.\"\"\"\n        if operator == \"-\":\n            if operand_type in [\"int\", \"float\"]:\n                return operand_type\n            else:\n                self.errors.append(TypeCheckError(\n                    message=f\"Unary minus operator cannot be applied to type '{operand_type}'\",\n                    suggestion=\"Use a numeric type with the negation operator\",\n                    position=position\n                ))\n                return None\n                \n        elif operator == \"!\":\n            if operand_type == \"bool\":\n                return \"bool\"\n            else:\n                self.errors.append(TypeCheckError(\n                    message=f\"Logical not operator cannot be applied to type '{operand_type}'\",\n                    suggestion=\"Use a boolean value or expression with the logical not operator\",\n                    position=position\n                ))\n                return None\n        \n        return None\n    \n    def _check_function_call(self, func_name: str, args: List[Dict[str, Any]], position: SourcePosition) -> Optional[str]:\n        \"\"\"Check function call for correct argument types and return the return type.\"\"\"\n        symbol = self.symbol_table.lookup(func_name)\n        \n        if not symbol or symbol.symbol_type != SymbolType.FUNCTION:\n            self.errors.append(TypeCheckError(\n                message=f\"Call to undefined function '{func_name}'\",\n                suggestion=\"Define the function before calling it or check for typos\",\n                position=position\n            ))\n            return None\n            \n        # Check argument count\n        params = symbol.type_info[\"params\"]\n        if len(args) != len(params):\n            self.errors.append(TypeCheckError(\n                message=f\"Function '{func_name}' expects {len(params)} arguments but got {len(args)}\",\n                suggestion=f\"Provide exactly {len(params)} arguments as defined in the function signature\",\n                position=position\n            ))\n            return None\n            \n        # Check argument types\n        for i, arg in enumerate(args):\n            arg_type = self._check_node(arg)\n            param_name, param_type = params[i]\n            \n            if arg_type and param_type and not self._are_types_compatible(param_type, arg_type):\n                self.errors.append(TypeCheckError(\n                    message=f\"Function '{func_name}' expects parameter '{param_name}' of type '{param_type}' but got '{arg_type}'\",\n                    suggestion=f\"Provide a value of type '{param_type}' or convert the argument to that type\",\n                    position=arg[\"position\"]\n                ))\n        \n        return symbol.type_info[\"return_type\"]\n    \n    def _check_method_call(self, member_access: Dict[str, Any], args: List[Dict[str, Any]], position: SourcePosition) -> Optional[str]:\n        \"\"\"Check method call for correct argument types and return the return type.\"\"\"\n        object_type = self._check_node(member_access[\"object\"])\n        method_name = member_access[\"member\"]\n        \n        if not object_type:\n            return None\n            \n        # Find the method in the type definition\n        method_info = self._get_method_info(object_type, method_name)\n        \n        if not method_info:\n            self.errors.append(TypeCheckError(\n                message=f\"Type '{object_type}' has no method named '{method_name}'\",\n                suggestion=f\"Check for typos or implement the method for type '{object_type}'\",\n                position=position\n            ))\n            return None\n            \n        # Check argument count (accounting for implicit self)\n        params = method_info[\"params\"]\n        expected_arg_count = len(params) - 1  # Subtract 1 for implicit self\n        \n        if len(args) != expected_arg_count:\n            self.errors.append(TypeCheckError(\n                message=f\"Method '{method_name}' expects {expected_arg_count} arguments but got {len(args)}\",\n                suggestion=f\"Provide exactly {expected_arg_count} arguments as defined in the method signature\",\n                position=position\n            ))\n            return None\n            \n        # Check argument types (starting from index 1 to skip self)\n        for i, arg in enumerate(args):\n            arg_type = self._check_node(arg)\n            _, param_type = params[i + 1]  # +1 to skip self\n            \n            if arg_type and param_type and not self._are_types_compatible(param_type, arg_type):\n                self.errors.append(TypeCheckError(\n                    message=f\"Method '{method_name}' expects argument of type '{param_type}' but got '{arg_type}'\",\n                    suggestion=f\"Provide a value of type '{param_type}' or convert the argument to that type\",\n                    position=arg[\"position\"]\n                ))\n        \n        return method_info[\"return_type\"]\n    \n    def _get_member_type(self, object_type: str, member_name: str, position: SourcePosition) -> Optional[str]:\n        \"\"\"Get the type of a member (field or method) of a struct or enum.\"\"\"\n        if not object_type:\n            return None\n            \n        # Look up the type\n        symbol = self.symbol_table.lookup(object_type)\n        \n        if not symbol or symbol.symbol_type != SymbolType.TYPE:\n            self.errors.append(TypeCheckError(\n                message=f\"Cannot access member '{member_name}' on non-struct/enum type '{object_type}'\",\n                suggestion=\"Use a struct or enum type with the member access operator\",\n                position=position\n            ))\n            return None\n            \n        type_info = symbol.type_info\n        kind = type_info.get(\"kind\", \"\")\n        \n        if kind == \"struct\":\n            # Check struct fields\n            fields = type_info.get(\"fields\", {})\n            if member_name in fields:\n                return fields[member_name]\n                \n            # Could be a method, which would be handled by the call node\n            \n        elif kind == \"enum\":\n            # For enums, members are typically methods, handled by the call node\n            pass\n            \n        self.errors.append(TypeCheckError(\n            message=f\"Type '{object_type}' has no member named '{member_name}'\",\n            suggestion=f\"Check for typos or add the member to type '{object_type}'\",\n            position=position\n        ))\n        \n        return None\n    \n    def _get_method_info(self, object_type: str, method_name: str) -> Optional[Dict[str, Any]]:\n        \"\"\"Get information about a method of a struct, enum, or trait.\"\"\"\n        # Look up the type\n        symbol = self.symbol_table.lookup(object_type)\n        \n        if not symbol or symbol.symbol_type != SymbolType.TYPE:\n            return None\n            \n        type_info = symbol.type_info\n        \n        # Find method implementation\n        # For now, methods are not properly modeled in our prototype\n        # This would require tracking method implementations for types\n        \n        # Simple placeholder for demo purposes\n        # In a real implementation, we'd look through the type's methods and trait implementations\n        return {\n            \"params\": [(\"self\", object_type)],  # Self parameter\n            \"return_type\": \"any\"  # Placeholder\n        }\n    \n    def _get_element_type(self, collection_type: str) -> Optional[str]:\n        \"\"\"Get the element type of a collection.\"\"\"\n        if not collection_type:\n            return None\n            \n        # Array types\n        if collection_type.startswith(\"Array<\") and collection_type.endswith(\">\"):\n            element_type = collection_type[6:-1]  # Extract type parameter\n            return element_type\n            \n        # Range type\n        if collection_type == \"Range\":\n            return \"int\"\n            \n        # String type (iterates characters)\n        if collection_type == \"string\":\n            return \"char\"\n            \n        # Other iterable types would need more sophisticated analysis\n        \n        return None\n    \n    def _get_awaitable_type(self, awaitable_type: str, position: SourcePosition) -> Optional[str]:\n        \"\"\"Get the result type of an awaitable expression.\"\"\"\n        if not awaitable_type:\n            return None\n            \n        # Task and Future types\n        if awaitable_type.startswith(\"Task<\") and awaitable_type.endswith(\">\"):\n            result_type = awaitable_type[5:-1]  # Extract type parameter\n            return result_type\n            \n        if awaitable_type.startswith(\"Future<\") and awaitable_type.endswith(\">\"):\n            result_type = awaitable_type[7:-1]  # Extract type parameter\n            return result_type\n            \n        # Not an awaitable type\n        self.errors.append(TypeCheckError(\n            message=f\"Type '{awaitable_type}' is not awaitable\",\n            suggestion=\"Use a Task<T> or Future<T> type that can be awaited in an async function\",\n            position=position\n        ))\n        return None\n    \n    def _check_match_pattern(self, subject_type: str, pattern: Dict[str, Any]) -> None:\n        \"\"\"\n        Check if a match pattern is compatible with the subject type.\n        \n        Args:\n            subject_type: The type of the match subject\n            pattern: The pattern AST node\n        \"\"\"\n        if pattern.get(\"node_type\") == \"identifier\":\n            # This is a binding pattern, already handled\n            return\n            \n        # For enum variant patterns\n        if pattern.get(\"node_type\") == \"variant_pattern\":\n            variant_name = pattern.get(\"name\", \"\")\n            \n            # Check if subject is an enum\n            symbol = self.symbol_table.lookup(subject_type)\n            if not symbol or symbol.symbol_type != SymbolType.TYPE:\n                self.errors.append(TypeCheckError(\n                    message=f\"Cannot match non-enum type '{subject_type}' against variant pattern\",\n                    suggestion=f\"Use a simple binding pattern or ensure the matched value is an enum\",\n                    position=pattern[\"position\"]\n                ))\n                return\n                \n            type_info = symbol.type_info\n            if type_info.get(\"kind\") != \"enum\":\n                self.errors.append(TypeCheckError(\n                    message=f\"Cannot match non-enum type '{subject_type}' against variant pattern\",\n                    suggestion=f\"Use a simple binding pattern or ensure the matched value is an enum\",\n                    position=pattern[\"position\"]\n                ))\n                return\n                \n            # Check if variant exists\n            variants = type_info.get(\"variants\", {})\n            if variant_name not in variants:\n                self.errors.append(TypeCheckError(\n                    message=f\"Enum '{subject_type}' has no variant named '{variant_name}'\",\n                    suggestion=f\"Use one of the defined variants: {', '.join(variants.keys())}\",\n                    position=pattern[\"position\"]\n                ))\n                return\n                \n            # Check pattern arguments match variant fields\n            variant_fields = variants[variant_name]\n            pattern_fields = pattern.get(\"fields\", [])\n            \n            if len(pattern_fields) != len(variant_fields):\n                self.errors.append(TypeCheckError(\n                    message=f\"Variant '{variant_name}' expects {len(variant_fields)} fields but got {len(pattern_fields)}\",\n                    suggestion=f\"Provide the correct number of fields for this variant\",\n                    position=pattern[\"position\"]\n                ))\n                \n            # More detailed field checking could be added here\n                \n        # Literal patterns\n        elif pattern.get(\"node_type\") == \"literal\":\n            literal_type = pattern.get(\"literal_type\", \"\")\n            \n            if not self._are_types_compatible(subject_type, literal_type):\n                self.errors.append(TypeCheckError(\n                    message=f\"Cannot match value of type '{subject_type}' against literal of type '{literal_type}'\",\n                    suggestion=f\"Use a pattern of type '{subject_type}'\",\n                    position=pattern[\"position\"]\n                ))\n    \n    def check_match_exhaustiveness(self, subject_type: str, branches: List[Dict[str, Any]], position: SourcePosition) -> None:\n        \"\"\"\n        Check if a match statement covers all possible variants of an enum.\n        \n        Args:\n            subject_type: The type being matched on\n            branches: The match branches\n            position: The source position of the match statement\n        \"\"\"\n        # Only check exhaustiveness for enum types\n        symbol = self.symbol_table.lookup(subject_type)\n        if not symbol or symbol.symbol_type != SymbolType.TYPE:\n            return\n            \n        type_info = symbol.type_info\n        if type_info.get(\"kind\") != \"enum\":\n            return\n            \n        # Get all variants for this enum\n        all_variants = set(type_info.get(\"variants\", {}).keys())\n        covered_variants = set()\n        has_wildcard = False\n        \n        # Check which variants are covered\n        for branch in branches:\n            pattern = branch.get(\"pattern\", {})\n            \n            if pattern.get(\"node_type\") == \"identifier\":\n                # This is a catch-all binding pattern\n                has_wildcard = True\n                break\n                \n            elif pattern.get(\"node_type\") == \"variant_pattern\":\n                variant_name = pattern.get(\"name\", \"\")\n                covered_variants.add(variant_name)\n        \n        # If we have a wildcard pattern, all variants are covered\n        if has_wildcard:\n            return\n            \n        # Check if all variants are covered\n        missing_variants = all_variants - covered_variants\n        if missing_variants:\n            self.errors.append(TypeCheckError(\n                message=f\"Match statement for enum '{subject_type}' is not exhaustive, missing variants: {', '.join(missing_variants)}\",\n                suggestion=\"Add patterns for all variants or include a catch-all pattern with '_'\",\n                position=position\n            ))", "size": 46485, "lastModified": 1741356378.3644187, "moduleContext": "src/semantic", "structure": {"classes": ["class", "TypeChecker", "from"], "functions": ["check_match_exhaustiveness", "_check_match_pattern", "_is_valid_type", "check", "_check_method_call", "_check_node", "_check_binary_op_types", "_register_declarations", "__init__", "_check_unary_op_types", "_get_member_type", "_check_function_call", "_are_types_compatible", "_get_awaitable_type", "_get_method_info", "_get_element_type", "__str__"], "imports": ["dataclass", "logging", "dataclasses", "SourcePosition", "index", "src", "SymbolTable", "the", "Dict", "a", "typing"]}, "stats": {"line_count": 1071, "function_count": 17, "class_count": 3, "complexity_estimate": 329}, "contentHash": "66a8937cfc19805c935cc8095cb11148"}
{"filePath": "src/semantic/symbol_table.py", "language": "Python", "content": "\"\"\"\nSymbol Table for Aegis programming language.\n\nThis module provides a symbol table implementation for tracking declarations\nand their scopes during semantic analysis.\n\"\"\"\n\nfrom typing import Dict, List, Any, Optional, Union\nfrom enum import Enum, auto\nfrom dataclasses import dataclass, field\n\nclass SymbolType(Enum):\n    \"\"\"Types of symbols that can be stored in the symbol table.\"\"\"\n    VARIABLE = auto()\n    FUNCTION = auto()\n    TYPE = auto()\n    TRAIT = auto()\n    MODULE = auto()\n\n@dataclass\nclass Symbol:\n    \"\"\"\n    Represents a symbol in the Aegis language.\n    \n    Attributes:\n        name: The name of the symbol\n        symbol_type: The type of symbol (variable, function, etc.)\n        type_info: Type information for the symbol\n        is_mutable: Whether the symbol can be modified (for variables)\n        scope: The scope in which the symbol is defined\n    \"\"\"\n    name: str\n    symbol_type: SymbolType\n    type_info: Any\n    is_mutable: bool = False\n    scope: str = \"\"\n    \n    def __str__(self) -> str:\n        return f\"{self.name} ({self.symbol_type.name})\"\n\n@dataclass\nclass Scope:\n    \"\"\"\n    Represents a lexical scope in the program.\n    \n    Attributes:\n        name: The name of the scope\n        parent: The parent scope, or None for global scope\n        symbols: Mapping of symbol names to Symbol objects\n        children: Child scopes\n    \"\"\"\n    name: str\n    parent: Optional['Scope'] = None\n    symbols: Dict[str, Symbol] = field(default_factory=dict)\n    children: List['Scope'] = field(default_factory=list)\n    \n    def add_symbol(self, symbol: Symbol) -> None:\n        \"\"\"Add a symbol to this scope.\"\"\"\n        self.symbols[symbol.name] = symbol\n    \n    def lookup_local(self, name: str) -> Optional[Symbol]:\n        \"\"\"Look up a symbol only in this scope.\"\"\"\n        return self.symbols.get(name)\n    \n    def __str__(self) -> str:\n        return f\"Scope({self.name}, {len(self.symbols)} symbols)\"\n\nclass SymbolTable:\n    \"\"\"\n    Symbol table for tracking declarations and their scopes.\n    \n    The symbol table maintains a hierarchy of scopes and allows looking up\n    symbols in the current and parent scopes.\n    \"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize an empty symbol table with a global scope.\"\"\"\n        self.global_scope = Scope(\"global\")\n        self.current_scope = self.global_scope\n        self.scope_stack = [self.global_scope]\n    \n    def enter_scope(self, name: str) -> None:\n        \"\"\"\n        Enter a new scope.\n        \n        Args:\n            name: The name of the new scope\n        \"\"\"\n        new_scope = Scope(name, parent=self.current_scope)\n        self.current_scope.children.append(new_scope)\n        self.current_scope = new_scope\n        self.scope_stack.append(new_scope)\n    \n    def exit_scope(self) -> None:\n        \"\"\"Exit the current scope and return to the parent scope.\"\"\"\n        if len(self.scope_stack) > 1:\n            self.scope_stack.pop()\n            self.current_scope = self.scope_stack[-1]\n    \n    def add_symbol(self, name: str, symbol_type: SymbolType, type_info: Any, is_mutable: bool = False) -> Symbol:\n        \"\"\"\n        Add a symbol to the current scope.\n        \n        Args:\n            name: The name of the symbol\n            symbol_type: The type of symbol (variable, function, etc.)\n            type_info: Type information for the symbol\n            is_mutable: Whether the symbol can be modified (for variables)\n            \n        Returns:\n            The created Symbol object\n        \"\"\"\n        symbol = Symbol(\n            name=name,\n            symbol_type=symbol_type,\n            type_info=type_info,\n            is_mutable=is_mutable,\n            scope=self.current_scope.name\n        )\n        self.current_scope.add_symbol(symbol)\n        return symbol\n    \n    def lookup(self, name: str) -> Optional[Symbol]:\n        \"\"\"\n        Look up a symbol in the current scope and its ancestors.\n        \n        Args:\n            name: The name of the symbol to look up\n            \n        Returns:\n            The Symbol object if found, None otherwise\n        \"\"\"\n        # Look in current scope and parent scopes\n        scope = self.current_scope\n        while scope:\n            symbol = scope.lookup_local(name)\n            if symbol:\n                return symbol\n            scope = scope.parent\n        \n        return None\n    \n    def lookup_in_scope(self, name: str, scope_name: str) -> Optional[Symbol]:\n        \"\"\"\n        Look up a symbol in a specific scope.\n        \n        Args:\n            name: The name of the symbol to look up\n            scope_name: The name of the scope to look in\n            \n        Returns:\n            The Symbol object if found, None otherwise\n        \"\"\"\n        # Find the scope with the given name\n        scope_to_check = self._find_scope(self.global_scope, scope_name)\n        if not scope_to_check:\n            return None\n        \n        return scope_to_check.lookup_local(name)\n    \n    def _find_scope(self, current: Scope, name: str) -> Optional[Scope]:\n        \"\"\"Recursively find a scope by name.\"\"\"\n        if current.name == name:\n            return current\n        \n        for child in current.children:\n            result = self._find_scope(child, name)\n            if result:\n                return result\n        \n        return None\n    \n    def get_all_symbols(self) -> List[Symbol]:\n        \"\"\"Get all symbols defined in all scopes.\"\"\"\n        symbols = []\n        self._collect_symbols(self.global_scope, symbols)\n        return symbols\n    \n    def _collect_symbols(self, scope: Scope, symbols: List[Symbol]) -> None:\n        \"\"\"Recursively collect symbols from a scope and its children.\"\"\"\n        symbols.extend(scope.symbols.values())\n        \n        for child in scope.children:\n            self._collect_symbols(child, symbols)\n    \n    def get_current_scope_name(self) -> str:\n        \"\"\"Get the name of the current scope.\"\"\"\n        return self.current_scope.name\n    \n    def get_scope_path(self) -> str:\n        \"\"\"Get the full path of the current scope.\"\"\"\n        path = []\n        scope = self.current_scope\n        \n        while scope:\n            path.insert(0, scope.name)\n            scope = scope.parent\n        \n        return \".\".join(path) ", "size": 6265, "lastModified": 1741356488.563146, "moduleContext": "src/semantic", "structure": {"classes": ["SymbolTable", "SymbolType", "class"], "functions": ["get_current_scope_name", "lookup_local", "__init__", "lookup_in_scope", "enter_scope", "get_all_symbols", "get_scope_path", "_collect_symbols", "lookup", "_find_scope", "__str__", "exit_scope", "add_symbol"], "imports": ["dataclass", "Enum", "dataclasses", "Dict", "enum", "a", "typing"]}, "stats": {"line_count": 199, "function_count": 13, "class_count": 3, "complexity_estimate": 36}, "contentHash": "d8b151c3bdd8eb28c6b6c6cca1f5fd79"}
{"filePath": "src/stdlib/stdlib.py", "language": "Python", "content": "class StandardLibrary:\n    \"\"\"Defines the core standard library functions for AegisLang.\"\"\"\n\n    def __init__(self):\n        self.library = {}\n\n    def register_builtin_functions(self):\n        \"\"\"Registers core built-in functions.\"\"\"\n        self.library[\"print\"] = {\n            \"params\": [(\"message\", \"string\")],\n            \"return\": \"void\",\n            \"llvm_ir\": self.generate_print_function(),\n        }\n\n        self.library[\"add\"] = {\n            \"params\": [(\"a\", \"int\"), (\"b\", \"int\")],\n            \"return\": \"int\",\n            \"llvm_ir\": self.generate_add_function(),\n        }\n\n    def generate_print_function(self):\n        \"\"\"Generates LLVM IR for a print function.\"\"\"\n        return \"\"\"\n        declare void @puts(i8*)\n        \n        define void @print(i8* %message) {\n            call void @puts(i8* %message)\n            ret void\n        }\n        \"\"\"\n\n    def generate_add_function(self):\n        \"\"\"Generates LLVM IR for an integer addition function.\"\"\"\n        return \"\"\"\n        define i64 @add(i64 %a, i64 %b) {\n            %sum = add i64 %a, %b\n            ret i64 %sum\n        }\n        \"\"\"\n\n\nclass ExtendedStandardLibrary(StandardLibrary):\n    \"\"\"Expands the standard library with more built-in functions.\"\"\"\n\n    def register_extended_functions(self):\n        \"\"\"Registers additional utility functions.\"\"\"\n\n        self.library[\"subtract\"] = {\n            \"params\": [(\"a\", \"int\"), (\"b\", \"int\")],\n            \"return\": \"int\",\n            \"llvm_ir\": self.generate_subtract_function(),\n        }\n\n        self.library[\"multiply\"] = {\n            \"params\": [(\"a\", \"int\"), (\"b\", \"int\")],\n            \"return\": \"int\",\n            \"llvm_ir\": self.generate_multiply_function(),\n        }\n\n        self.library[\"divide\"] = {\n            \"params\": [(\"a\", \"int\"), (\"b\", \"int\")],\n            \"return\": \"Result<int, string>\",\n            \"llvm_ir\": self.generate_divide_function(),\n        }\n\n        self.library[\"length\"] = {\n            \"params\": [(\"s\", \"string\")],\n            \"return\": \"int\",\n            \"llvm_ir\": self.generate_length_function(),\n        }\n\n        self.library[\"concat\"] = {\n            \"params\": [(\"s1\", \"string\"), (\"s2\", \"string\")],\n            \"return\": \"string\",\n            \"llvm_ir\": self.generate_concat_function(),\n        }\n\n    def generate_subtract_function(self):\n        \"\"\"Generates LLVM IR for subtraction.\"\"\"\n        return \"\"\"\n        define i64 @subtract(i64 %a, i64 %b) {\n            %diff = sub i64 %a, %b\n            ret i64 %diff\n        }\n        \"\"\"\n\n    def generate_multiply_function(self):\n        \"\"\"Generates LLVM IR for multiplication.\"\"\"\n        return \"\"\"\n        define i64 @multiply(i64 %a, i64 %b) {\n            %product = mul i64 %a, %b\n            ret i64 %product\n        }\n        \"\"\"\n\n    def generate_divide_function(self):\n        \"\"\"Generates LLVM IR for safe division (returns Result<int, string>).\"\"\"\n        return \"\"\"\n        define i64 @divide(i64 %a, i64 %b) {\n            %is_zero = icmp eq i64 %b, 0\n            br i1 %is_zero, label %error, label %continue\n\n        error:\n            ret i64 -1  ; Use a special value to indicate error (to be replaced with proper error handling)\n        \n        continue:\n            %quotient = sdiv i64 %a, %b\n            ret i64 %quotient\n        }\n        \"\"\"\n\n    def generate_length_function(self):\n        \"\"\"Generates LLVM IR for string length calculation.\"\"\"\n        return \"\"\"\n        declare i64 @strlen(i8*)\n\n        define i64 @length(i8* %s) {\n            %len = call i64 @strlen(i8* %s)\n            ret i64 %len\n        }\n        \"\"\"\n\n    def generate_concat_function(self):\n        \"\"\"Generates LLVM IR for string concatenation.\"\"\"\n        return \"\"\"\n        declare i8* @strcat(i8*, i8*)\n\n        define i8* @concat(i8* %s1, i8* %s2) {\n            %result = call i8* @strcat(i8* %s1, i8* %s2)\n            ret i8* %result\n        }\n        \"\"\"\n\n\nclass FullStandardLibrary(ExtendedStandardLibrary):\n    \"\"\"Further expands the standard library with file I/O, networking, and date/time utilities.\"\"\"\n\n    def register_advanced_functions(self):\n        \"\"\"Registers file I/O, networking, and date/time functions.\"\"\"\n\n        # File I/O Functions\n        self.library[\"read_file\"] = {\n            \"params\": [(\"filename\", \"string\")],\n            \"return\": \"string\",\n            \"llvm_ir\": self.generate_read_file_function(),\n        }\n\n        self.library[\"write_file\"] = {\n            \"params\": [(\"filename\", \"string\"), (\"content\", \"string\")],\n            \"return\": \"bool\",\n            \"llvm_ir\": self.generate_write_file_function(),\n        }\n\n        # HTTP Networking Functions\n        self.library[\"http_get\"] = {\n            \"params\": [(\"url\", \"string\")],\n            \"return\": \"string\",\n            \"llvm_ir\": self.generate_http_get_function(),\n        }\n\n        self.library[\"http_post\"] = {\n            \"params\": [(\"url\", \"string\"), (\"data\", \"string\")],\n            \"return\": \"string\",\n            \"llvm_ir\": self.generate_http_post_function(),\n        }\n\n        # Date/Time Functions\n        self.library[\"current_timestamp\"] = {\n            \"params\": [],\n            \"return\": \"int\",\n            \"llvm_ir\": self.generate_current_timestamp_function(),\n        }\n\n        self.library[\"format_date\"] = {\n            \"params\": [(\"timestamp\", \"int\"), (\"format\", \"string\")],\n            \"return\": \"string\",\n            \"llvm_ir\": self.generate_format_date_function(),\n        }\n\n    def generate_read_file_function(self):\n        \"\"\"Generates LLVM IR for reading a file.\"\"\"\n        return \"\"\"\n        declare i8* @read_file(i8*)\n        \n        define i8* @read_file_wrapper(i8* %filename) {\n            %content = call i8* @read_file(i8* %filename)\n            ret i8* %content\n        }\n        \"\"\"\n\n    def generate_write_file_function(self):\n        \"\"\"Generates LLVM IR for writing to a file.\"\"\"\n        return \"\"\"\n        declare i1 @write_file(i8*, i8*)\n        \n        define i1 @write_file_wrapper(i8* %filename, i8* %content) {\n            %success = call i1 @write_file(i8* %filename, i8* %content)\n            ret i1 %success\n        }\n        \"\"\"\n\n    def generate_http_get_function(self):\n        \"\"\"Generates LLVM IR for HTTP GET requests.\"\"\"\n        return \"\"\"\n        declare i8* @http_get(i8*)\n        \n        define i8* @http_get_wrapper(i8* %url) {\n            %response = call i8* @http_get(i8* %url)\n            ret i8* %response\n        }\n        \"\"\"\n\n    def generate_http_post_function(self):\n        \"\"\"Generates LLVM IR for HTTP POST requests.\"\"\"\n        return \"\"\"\n        declare i8* @http_post(i8*, i8*)\n        \n        define i8* @http_post_wrapper(i8* %url, i8* %data) {\n            %response = call i8* @http_post(i8* %url, i8* %data)\n            ret i8* %response\n        }\n        \"\"\"\n\n    def generate_current_timestamp_function(self):\n        \"\"\"Generates LLVM IR for getting the current timestamp.\"\"\"\n        return \"\"\"\n        declare i64 @current_timestamp()\n        \n        define i64 @current_timestamp_wrapper() {\n            %time = call i64 @current_timestamp()\n            ret i64 %time\n        }\n        \"\"\"\n\n    def generate_format_date_function(self):\n        \"\"\"Generates LLVM IR for formatting timestamps.\"\"\"\n        return \"\"\"\n        declare i8* @format_date(i64, i8*)\n        \n        define i8* @format_date_wrapper(i64 %timestamp, i8* %format) {\n            %formatted_date = call i8* @format_date(i64 %timestamp, i8* %format)\n            ret i8* %formatted_date\n        }\n        \"\"\"\n\n\n# Example usage:\nif __name__ == \"__main__\":\n    lib = FullStandardLibrary()\n    lib.register_builtin_functions()\n    lib.register_extended_functions()\n    lib.register_advanced_functions()\n    for func, details in lib.library.items():\n        print(func, details[\"params\"], details[\"return\"])\n", "size": 7787, "lastModified": 1741345565.6466293, "moduleContext": "src/stdlib", "structure": {"classes": ["FullStandardLibrary", "ExtendedStandardLibrary", "StandardLibrary"], "functions": ["register_advanced_functions", "generate_multiply_function", "register_extended_functions", "generate_read_file_function", "generate_http_get_function", "generate_format_date_function", "register_builtin_functions", "generate_current_timestamp_function", "__init__", "generate_divide_function", "generate_subtract_function", "generate_print_function", "generate_http_post_function", "generate_add_function", "generate_write_file_function", "generate_length_function", "generate_concat_function"], "imports": []}, "stats": {"line_count": 255, "function_count": 17, "class_count": 3, "complexity_estimate": 49}, "contentHash": "e58b27fed84c3aead9558dee0bc41c13"}
{"filePath": "src/compiler/main_compiler.py", "language": "Python", "content": "\"\"\"\nAegisLang Compiler\nThis file implements the Lexer, Parser, Type Checker, LLVM IR Generator, and JIT Compiler.\n\nThe compiler follows a standard pipeline:\nlex \u2192 parse \u2192 type-check \u2192 generate IR \u2192 JIT execute\n\nThe semantic analysis phase ensures type safety and validity before code generation occurs.\n\"\"\"\n\nimport sys\nimport os\nfrom src.lexer.lexer import lex\nfrom src.parser.parser import AegisParser\nfrom src.semantic.type_checker import TypeChecker\nfrom src.semantic.symbol_table import SymbolTable \nfrom src.compiler.code_generator import CodeGenerator\nfrom src.jit.jit_compiler import JITCompiler\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n\n# -------------------------------\n# Main Compiler Flow\n# -------------------------------\ndef compile_file(source_path):\n    \"\"\"\n    Compile an Aegis source file (.ae) through the full compilation pipeline.\n    \n    Args:\n        source_path: Path to the source file\n        \n    Returns:\n        A tuple of (success, result) where:\n        - success is a boolean indicating if compilation succeeded\n        - result contains either the execution result or error messages\n    \"\"\"\n    try:\n        # Read source code\n        logger.info(f\"Reading source file: {source_path}\")\n        with open(source_path, \"r\") as f:\n            source_code = f.read()\n            \n        # Extract file name for error reporting\n        file_name = os.path.basename(source_path)\n        \n        # 1. Lexical Analysis\n        logger.info(\"Starting lexical analysis\")\n        tokens = lex(source_code)\n        logger.info(f\"Lexical analysis complete: {len(tokens)} tokens\")\n        \n        # 2. Parsing\n        logger.info(\"Starting parsing\")\n        parser = AegisParser(tokens)\n        ast = parser.parse()\n        \n        if parser.errors:\n            # Parse errors found, display and return\n            logger.error(f\"Parsing failed with {len(parser.errors)} errors\")\n            error_messages = []\n            for error in parser.errors:\n                error_messages.append(f\"{file_name}:{error.line}:{error.column}: Parse Error: {error.message}\")\n                # Add suggestion if available\n                if hasattr(error, 'suggestion') and error.suggestion:\n                    error_messages.append(f\"Suggestion: {error.suggestion}\")\n            \n            return False, \"\\n\".join(error_messages)\n        \n        logger.info(\"Parsing complete\")\n        \n        # 3. Semantic Analysis\n        logger.info(\"Starting semantic analysis\")\n        symbol_table = SymbolTable()  # Create new symbol table\n        type_checker = TypeChecker()  # Create type checker\n        semantic_errors = type_checker.check(ast)  # Perform semantic analysis\n        \n        if semantic_errors:\n            # Semantic errors found, display and return\n            logger.error(f\"Semantic analysis failed with {len(semantic_errors)} errors\")\n            error_messages = []\n            for error in semantic_errors:\n                error_messages.append(f\"{error}\")  # TypeCheckError already formats properly\n            \n            return False, \"\\n\".join(error_messages)\n            \n        logger.info(\"Semantic analysis complete - no errors found\")\n        \n        # 4. Code Generation (only if no semantic errors)\n        logger.info(\"Starting LLVM IR generation\")\n        code_gen = CodeGenerator(ast)\n        llvm_ir = code_gen.generate()\n        logger.info(\"LLVM IR generation complete\")\n        \n        # 5. JIT Compilation and Execution\n        logger.info(\"Starting JIT compilation and execution\")\n        jit_compiler = JITCompiler(llvm_ir)\n        execution_result = jit_compiler.compile_and_execute()\n        logger.info(\"Execution complete\")\n        \n        return True, execution_result\n        \n    except Exception as e:\n        logger.error(f\"Compilation failed with exception: {str(e)}\")\n        return False, f\"Internal compiler error: {str(e)}\"\n\ndef display_error(error_message):\n    \"\"\"Format and display an error message with AI-friendly suggestions.\"\"\"\n    print(\"\u274c Compilation Error:\")\n    print(error_message)\n\ndef main():\n    \"\"\"Main entry point for the compiler.\"\"\"\n    logger.info(\"Starting Aegis compiler\")\n    \n    if len(sys.argv) < 2:\n        print(\"Usage: python aegis_compiler.py <source_file.ae>\")\n        return 1\n        \n    source_path = sys.argv[1]\n    \n    # Check if file exists\n    if not os.path.exists(source_path):\n        print(f\"Error: File not found: {source_path}\")\n        return 1\n        \n    # Check file extension\n    if not source_path.endswith('.ae'):\n        print(f\"Warning: File does not have .ae extension: {source_path}\")\n    \n    # Compile the file\n    success, result = compile_file(source_path)\n    \n    if not success:\n        display_error(result)\n        return 1\n    else:\n        print(\"\u2705 Compilation and execution successful:\")\n        print(result)\n        return 0\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n", "size": 4947, "lastModified": 1741356963.985115, "moduleContext": "src/compiler", "structure": {"classes": [], "functions": ["main", "display_error", "compile_file"], "imports": ["sys", "TypeChecker", "CodeGenerator", "src", "SymbolTable", "get_logger", "lex", "utils", "JITCompiler", "os", "AegisParser"]}, "stats": {"line_count": 143, "function_count": 3, "class_count": 0, "complexity_estimate": 31}, "contentHash": "444130d7eff95db394270c60b83940ec"}
{"filePath": "src/compiler/code_generator.py", "language": "Python", "content": "from llvmlite import ir, binding\nfrom utils.logger import get_logger\n\nlogger = get_logger(__name__)\n# -------------------------------\n# LLVM IR Code Generator\n# -------------------------------\nclass CodeGenerator:\n    \"\"\"Generates LLVM IR from the parsed AST.\"\"\"\n    def __init__(self, ast):\n        logger.info(\"Starting CodeGenerator...\")\n        self.ast = ast\n        self.module = ir.Module(name=\"AegisModule\")\n        self.symbol_table = {}  # Stores functions and struct types\n\n    def generate(self):\n        \"\"\"Generates LLVM IR for the entire AST.\"\"\"\n        logger.info(\"Generating LLVM IR...\")\n        for node in self.ast.children:\n            if node.node_type == \"Struct\":\n                self.generate_struct(node)\n            elif node.node_type == \"Function\":\n                self.generate_function(node)\n        logger.debug(f\"Generated LLVM IR:\\n{str(self.module)}\")\n        llvm_ir = str(self.module)\n        logger.debug(f\"LLVM IR:\\n{llvm_ir}\")\n        return llvm_ir\n\n    def generate_struct(self, struct_node):\n        \"\"\"Generates LLVM struct types.\"\"\"\n        logger.info(\"Generating struct...\")\n        struct_name = struct_node.value\n        field_types = []\n        for field in struct_node.children:\n            field_name, field_type = field.value\n            llvm_type = self.get_llvm_type(field_type)\n            field_types.append(llvm_type)\n        struct_type = ir.LiteralStructType(field_types)\n        self.symbol_table[struct_name] = struct_type\n\n    def generate_function(self, function_node):\n        \"\"\"Generates LLVM IR for function definitions with proper body implementation.\"\"\"\n        logger.info(\"Generating function...\")\n        # Extract function details\n        func_name = function_node.value\n        param_list = function_node.children[0].value  # [(param_name, param_type), ...]\n        return_type = function_node.children[1].value\n\n        # Get LLVM types\n        llvm_return_type = self.get_llvm_type(return_type)\n        llvm_param_types = [self.get_llvm_type(ptype) for _, ptype in param_list]\n\n        # Create function type and declaration\n        func_type = ir.FunctionType(llvm_return_type, llvm_param_types)\n        func = ir.Function(self.module, func_type, name=func_name)\n\n        # Create basic block for function body\n        block = func.append_basic_block(name=\"entry\")\n        builder = ir.IRBuilder(block)\n\n        # Store parameter references in symbol table for use in function body\n        local_vars = {}\n        for i, (param_name, _) in enumerate(param_list):\n            param = func.args[i]\n            param.name = param_name\n            # Allocate memory for parameter and store value\n            alloca = builder.alloca(param.type, name=param_name)\n            builder.store(param, alloca)\n            local_vars[param_name] = alloca\n\n        # For now, just generate a simple return statement (placeholder)\n        # In a real implementation, we'd parse and generate IR for the function body\n        if return_type in [\"int\", \"bool\"]:\n            builder.ret(ir.Constant(self.get_llvm_type(return_type), 0))\n        elif return_type == \"float\":\n            builder.ret(ir.Constant(self.get_llvm_type(return_type), 0.0))\n        elif return_type == \"string\":\n            # Return empty string by default\n            empty_str = ir.Constant(ir.ArrayType(ir.IntType(8), 1), bytearray([0]))\n            builder.ret(empty_str)\n        else:\n            # For custom types, create a null pointer\n            builder.ret(ir.Constant(self.get_llvm_type(return_type), None))\n\n        # Register function in symbol table\n        self.symbol_table[func_name] = func\n\n    def get_llvm_type(self, aegis_type):\n        \"\"\"Maps Aegis types to LLVM types.\"\"\"\n        logger.info(\"Getting LLVM type...\")\n        llvm_type_map = {\n            \"int\": ir.IntType(64),\n            \"float\": ir.FloatType(),\n            \"bool\": ir.IntType(1),\n            \"string\": ir.PointerType(ir.IntType(8)),\n        }\n        logger.debug(f\"LLVM type: {llvm_type_map.get(aegis_type, ir.VoidType())}\")\n        return llvm_type_map.get(aegis_type, ir.VoidType())\n", "size": 4113, "lastModified": 1741346203.3111002, "moduleContext": "src/compiler", "structure": {"classes": ["CodeGenerator"], "functions": ["generate_function", "get_llvm_type", "__init__", "generate", "generate_struct"], "imports": ["llvmlite", "get_logger", "the", "utils", "ir"]}, "stats": {"line_count": 99, "function_count": 5, "class_count": 1, "complexity_estimate": 20}, "contentHash": "6e6ef4d230d82023c474b40d4b6584d5"}
{"filePath": "src/pkg_manager/package_manager.py", "language": "Python", "content": "import os\nimport json\n\n\nclass AegisPackageManager:\n    \"\"\"Handles package management for AegisLang, including dependency installation and module tracking.\"\"\"\n\n    PACKAGE_DIR = \"./aegis_packages\"\n    CONFIG_FILE = \"aegis.json\"\n\n    def __init__(self):\n        \"\"\"Initializes the package manager and ensures package directory exists.\"\"\"\n        if not os.path.exists(self.PACKAGE_DIR):\n            os.makedirs(self.PACKAGE_DIR)\n\n    def create_project(self, project_name):\n        \"\"\"Creates a new AegisLang project with a package config file.\"\"\"\n        project_path = os.path.join(self.PACKAGE_DIR, project_name)\n        if not os.path.exists(project_path):\n            os.makedirs(project_path)\n            config_path = os.path.join(project_path, self.CONFIG_FILE)\n            with open(config_path, \"w\") as config_file:\n                json.dump(\n                    {\"name\": project_name, \"dependencies\": {}}, config_file, indent=4\n                )\n            return f\"Project '{project_name}' created successfully.\"\n        else:\n            return f\"Project '{project_name}' already exists.\"\n\n    def install_package(self, project_name, package_name, package_version=\"latest\"):\n        \"\"\"Installs a package for a given AegisLang project.\"\"\"\n        project_path = os.path.join(self.PACKAGE_DIR, project_name)\n        config_path = os.path.join(project_path, self.CONFIG_FILE)\n\n        if not os.path.exists(config_path):\n            return f\"Project '{project_name}' does not exist. Create it first.\"\n\n        # Load current dependencies\n        with open(config_path, \"r\") as config_file:\n            config_data = json.load(config_file)\n\n        # Add new package\n        config_data[\"dependencies\"][package_name] = package_version\n\n        # Save updated config\n        with open(config_path, \"w\") as config_file:\n            json.dump(config_data, config_file, indent=4)\n\n        return f\"Package '{package_name}@{package_version}' installed for project '{project_name}'.\"\n\n    def list_dependencies(self, project_name):\n        \"\"\"Lists all installed dependencies for a project.\"\"\"\n        project_path = os.path.join(self.PACKAGE_DIR, project_name)\n        config_path = os.path.join(project_path, self.CONFIG_FILE)\n\n        if not os.path.exists(config_path):\n            return f\"Project '{project_name}' does not exist.\"\n\n        with open(config_path, \"r\") as config_file:\n            config_data = json.load(config_file)\n\n        return config_data.get(\"dependencies\", {})\n", "size": 2494, "lastModified": 1741345565.645483, "moduleContext": "src/pkg_manager", "structure": {"classes": ["AegisPackageManager"], "functions": ["create_project", "list_dependencies", "__init__", "install_package"], "imports": ["json", "os"]}, "stats": {"line_count": 63, "function_count": 4, "class_count": 1, "complexity_estimate": 16}, "contentHash": "0fb1b4de790a0deccf21e40fc55f0357"}
